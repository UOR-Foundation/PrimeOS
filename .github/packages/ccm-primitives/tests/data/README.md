# Test Data Directory

This directory contains the official CCM-BJC v1.0 test vector suite.

## Files

- `bjc_test_vectors.bin` - Binary test vectors (80KB)
  - Generated by running: `cargo test generate_official_test_vectors -- --nocapture`
  - Contains 2,042 test vectors covering n values: 3, 4, 8, 10, 16, 32, 64

## Binary Format

The binary file follows this structure:

### Header (8 bytes)
- Magic: "BJCT" (4 bytes)
- Version: 1 (1 byte)
- N count: Number of different n values (1 byte)
- Reserved: (2 bytes)

### Test Sets
For each n value:
- n value (1 byte)
- Alpha vector length (1 byte)
- Alpha values (8 bytes each, f64 big-endian)
- Vector count (4 bytes, u32 big-endian)
- Test vectors (variable length each)

### Test Vector Format
Each test vector contains:
- n (1 byte)
- log2(k) (1 byte)
- Input length (2 bytes, u16 big-endian)
- Packet length (2 bytes, u16 big-endian)
- Input bytes
- Packet bytes
- Description length (1 byte)
- Description (UTF-8 string)

## Test Coverage

- **n=3**: 120 vectors (8 exhaustive + edge cases + random)
- **n=4**: 130 vectors (16 exhaustive + edge cases + random)
- **n=8**: 378 vectors (256 exhaustive + edge cases + random)
- **n=10**: 524 vectors (edge cases + systematic + random)
- **n=16**: 530 vectors (edge cases + systematic + random)
- **n=32**: 230 vectors (edge cases + systematic + random)
- **n=64**: 130 vectors (edge cases + systematic + random)

Total: 2,042 test vectors

## Validation

Run the conformance test to validate against these vectors:
```bash
cargo test conformance_test --all-features
```

## Example Usage

### Reading Test Vectors

```rust
use ccm_primitives::test_vectors::serialization::read_binary;
use std::fs::File;
use std::io::BufReader;

// Load test vectors
let file = File::open("tests/data/bjc_test_vectors.bin")?;
let mut reader = BufReader::new(file);
let test_sets = read_binary(&mut reader)?;

// Process each test set
for set in &test_sets {
    println!("Testing n={} with {} vectors", set.n, set.vectors.len());
    
    for vector in &set.vectors {
        // Each vector contains:
        // - vector.input: Original input bytes
        // - vector.expected_packet: Expected BJC packet
        // - vector.alpha: Alpha values used
        // - vector.k: Page modulus
        // - vector.description: Test case description
    }
}
```

### Using Test Vectors for Validation

```rust
use ccm_primitives::{encode_bjc, decode_bjc, BitWord};

// Example: Validate a single test vector for n=8
fn validate_vector(vector: &TestVector<f64>) -> Result<(), String> {
    // Convert input to BitWord
    let word = BitWord::<8>::from(vector.input[0]);
    
    // Encode
    let packet = encode_bjc(&word, &vector.alpha, vector.k, false)?;
    
    // Verify packet matches expected
    if packet != vector.expected_packet {
        return Err("Packet mismatch".to_string());
    }
    
    // Decode and verify bijectivity
    let decoded = decode_bjc::<f64, 8>(&packet, &vector.alpha)?;
    if decoded.to_usize() as u8 != vector.input[0] {
        return Err("Bijectivity failed".to_string());
    }
    
    Ok(())
}
```

### Generating Your Own Test Vectors

```rust
use ccm_primitives::test_vectors::{
    generator::generate_test_vectors,
    standard_alphas,
};

// Generate test vectors for n=8
let alpha = standard_alphas::alpha_n8::<f64>();
let test_set = generate_test_vectors(8, alpha);

// Test set contains:
// - Edge cases (all zeros, all ones, etc.)
// - Systematic patterns (single bits, powers of 2)
// - Exhaustive coverage for small n
// - Random test cases
```

## Test Vector Categories

Each test set includes vectors from these categories:

1. **Edge Cases**
   - All zeros
   - All ones
   - Alternating bits (0xAA...)
   - Klein group edge (last 2 bits set)
   - Minimum/maximum resonance patterns

2. **Systematic Patterns**
   - Single bit set at each position
   - Powers of 2
   - Sequential values

3. **Exhaustive Coverage** (for n â‰¤ 8)
   - Every possible input value

4. **Random Vectors**
   - Pseudo-random patterns with reproducible seeds