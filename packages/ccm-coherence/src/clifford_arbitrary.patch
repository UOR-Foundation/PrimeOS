diff --git a/src/clifford.rs b/src/clifford.rs
index 1234567..abcdefg 100644
--- a/src/clifford.rs
+++ b/src/clifford.rs
@@ -21,13 +21,29 @@ pub struct CliffordAlgebra<P: Float> {
 
 impl<P: Float> CliffordAlgebra<P> {
     /// Generate Euclidean Clifford algebra Cl(n) with positive definite metric
+    /// 
+    /// # Safety
+    /// For dimensions > 12, this may require significant memory (2^n basis elements).
+    /// Consider using ArbitraryCliffordAlgebra for large dimensions.
     pub fn generate(n: usize) -> Result<Self, CcmError> {
-        if n > 12 {
-            // Practical limit to avoid excessive memory usage
-            // 2^12 = 4096 basis elements
+        Self::generate_with_limit(n, 12)
+    }
+    
+    /// Generate with a custom dimension limit
+    pub fn generate_with_limit(n: usize, limit: usize) -> Result<Self, CcmError> {
+        if n > limit {
             return Err(CcmError::InvalidInput);
         }
 
+        // Check for potential overflow
+        if n >= core::mem::size_of::<usize>() * 8 {
+            return Err(CcmError::InvalidInput);
+        }
+        
+        // Memory check (rough estimate)
+        let estimated_mb = (1usize << n).saturating_mul(16) / (1024 * 1024);
+        if estimated_mb > 1000 { // 1GB limit
+            return Err(CcmError::InvalidLength);
+        }
+        
         Ok(Self {
             dimension: n,
             signature: (n, 0, 0), // Euclidean signature
@@ -36,8 +52,18 @@ impl<P: Float> CliffordAlgebra<P> {
     }
 
     /// Generate Clifford algebra with specified metric signature
+    /// 
+    /// # Safety
+    /// For total dimension > 12, this may require significant memory.
     pub fn with_signature(p: usize, q: usize, r: usize) -> Result<Self, CcmError> {
+        Self::with_signature_limit(p, q, r, 12)
+    }
+    
+    /// Generate with specified metric signature and custom limit
+    pub fn with_signature_limit(p: usize, q: usize, r: usize, limit: usize) -> Result<Self, CcmError> {
         let n = p + q + r;
-        if n > 12 {
+        if n > limit {
             return Err(CcmError::InvalidInput);
         }
+        
+        // Check for overflow
+        if n >= core::mem::size_of::<usize>() * 8 {
+            return Err(CcmError::InvalidInput);
+        }
 
         Ok(Self {