//! Comprehensive tests for BJC codec support in ccm-symmetry
//!
//! These tests ensure that ccm-symmetry correctly implements the symmetry
//! operations required by the BJC (Bijective-Junction Codec) specification.

use ccm_symmetry::{
    actions::{BitWordAction, GroupAction, KleinCliffordAction},
    group::{GroupElement, SymmetryGroup},
    invariants::{verify_resonance_preservation, ResonanceInvariant, Invariant},
};
use ccm_core::BitWord;
use ccm_coherence::CliffordElement;
use ccm_embedding::{AlphaVec, Resonance};

#[cfg(test)]
mod klein_group_bjc_tests {
    use super::*;

    /// Test Klein group operations for BJC bijectivity (last 2 bits)
    /// Per BJC spec: Klein classes can have 1, 2, or 4 distinct resonance values
    /// Bijectivity requires: every bit pattern has unique Klein minimum
    #[test]
    fn test_klein_bijectivity() {
        // Test for various bit lengths in BJC range [3, 64] and extended range
        let test_sizes = vec![3, 4, 8, 16, 32, 53, 64, 128, 256, 512, 1024, 2048, 4096];
        
        for n in test_sizes {
            // Skip very large sizes in CI (test locally)
            if n > 256 && std::env::var("CI").is_ok() {
                continue;
            }
            
            let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
            
            // Verify Klein group has exactly 4 elements
            assert_eq!(group.order(), Some(4), "Klein group should have order 4 for n={}", n);
            
            // Test that Klein group is generated by flips on last two bits
            let generators = group.generators();
            assert_eq!(generators.len(), 2, "Klein group should have 2 generators");
            
            // For larger n, test a sample of bit patterns
            let test_values: Vec<u64> = if n <= 16 {
                (0..(1u64 << n)).collect()
            } else {
                // Test edge cases and random samples
                let mut vals = vec![0, 1, 2, 3];
                if n < 64 {
                    vals.push((1u64 << (n.min(63) - 1)) - 1);
                    vals.push((1u64 << n) - 1);
                } else {
                    vals.push(u64::MAX >> 1);
                    vals.push(u64::MAX);
                }
                // Add some random values
                use std::collections::hash_map::DefaultHasher;
                use std::hash::{Hash, Hasher};
                for i in 0..100 {
                    let mut hasher = DefaultHasher::new();
                    i.hash(&mut hasher);
                    n.hash(&mut hasher);
                    let random = hasher.finish();
                    if n < 64 {
                        vals.push(random % (1u64 << n));
                    } else if n == 64 {
                        vals.push(random);
                    } else {
                        vals.push(random);
                    }
                }
                vals
            };
            
            // Track Klein minima for bijectivity check
            let mut klein_minima = std::collections::HashMap::new();
            
            for &val in &test_values {
                let test_word = if n <= 64 {
                    BitWord::from_u64(val, n)
                } else {
                    // For n > 64, create larger BitWord
                    let mut word = BitWord::new(n);
                    // Set bits from val in the first 64 bits
                    for i in 0..64.min(n) {
                        if (val >> i) & 1 == 1 {
                            word.set_bit(i, true);
                        }
                    }
                    word
                };
                
                // Apply Klein transformations
                let action = BitWordAction::new(n);
                let identity = group.identity();
                let flip_n2 = &generators[0]; // Flip bit n-2
                let flip_n1 = &generators[1]; // Flip bit n-1
                let flip_both = group.multiply(flip_n2, flip_n1).unwrap();
                
                // Get all 4 Klein orbit members
                let b0 = action.apply(&identity, &test_word).unwrap();
                let b1 = action.apply(flip_n2, &test_word).unwrap();
                let b2 = action.apply(flip_n1, &test_word).unwrap();
                let b3 = action.apply(&flip_both, &test_word).unwrap();
                
                // Verify we have 4 distinct elements
                let orbit = vec![b0.clone(), b1.clone(), b2.clone(), b3.clone()];
                let unique_count = orbit.iter().collect::<std::collections::HashSet<_>>().len();
                assert_eq!(unique_count, 4, "Klein orbit should have 4 distinct elements for n={}, val={}", n, val);
                
                // Verify Klein class properties
                let alpha = AlphaVec::<f64>::mathematical(n).unwrap();
                assert!(alpha.verify_unity_constraint(), "Unity constraint should hold for n={}", n);
                
                // Find the Klein minimum (for bijectivity)
                let resonances = vec![
                    (b0.clone(), b0.r(&alpha)),
                    (b1.clone(), b1.r(&alpha)),
                    (b2.clone(), b2.r(&alpha)),
                    (b3.clone(), b3.r(&alpha)),
                ];
                
                let (b_min, r_min) = resonances.iter()
                    .min_by(|(b1, r1), (b2, r2)| {
                        match r1.partial_cmp(r2).unwrap() {
                            std::cmp::Ordering::Equal => {
                                // Tie-break by smallest integer (as per BJC spec)
                                b1.to_usize().cmp(&b2.to_usize())
                            },
                            other => other,
                        }
                    })
                    .unwrap();
                
                // For bijectivity: each Klein orbit has unique minimum
                // and we can recover the original from (b_min, flip_bits)
                // Compute flip bits by comparing last two bit positions
                let flip_n2 = test_word.bit(n-2) != b_min.bit(n-2);
                let flip_n1 = test_word.bit(n-1) != b_min.bit(n-1);
                let flip_bits = ((flip_n2 as u8) << 0) | ((flip_n1 as u8) << 1);
                
                // Record this Klein minimum using its bit pattern
                let min_key = (0..n).map(|i| if b_min.bit(i) { 1u8 } else { 0u8 }).collect::<Vec<_>>();
                if let Some(existing) = klein_minima.get(&min_key) {
                    // Check that same minimum maps to same Klein orbit
                    let existing_orbit: std::collections::HashSet<_> = 
                        <BitWord as Resonance<f64>>::class_members(existing).into_iter().collect();
                    let current_orbit: std::collections::HashSet<_> = 
                        orbit.iter().cloned().collect();
                    assert_eq!(existing_orbit, current_orbit,
                        "Same Klein minimum should map to same orbit for n={}", n);
                } else {
                    klein_minima.insert(min_key, test_word.clone());
                }
            }
            
            println!("Tested {} bit patterns for n={}, found {} unique Klein minima",
                test_values.len(), n, klein_minima.len());
        }
    }

    /// Test that Klein group correctly identifies bit positions n-2 and n-1
    #[test]
    fn test_klein_bit_positions() {
        let test_sizes = vec![3, 8, 16, 32, 64];
        
        for n in test_sizes {
            let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
            let generators = group.generators();
            
            // First generator should flip bit n-2
            let g1 = &generators[0];
            assert!(g1.params[n-2] < 0.0, "First Klein generator should flip bit {} for n={}", n-2, n);
            
            // Second generator should flip bit n-1
            let g2 = &generators[1];
            assert!(g2.params[n-1] < 0.0, "Second Klein generator should flip bit {} for n={}", n-1, n);
            
            // All other bits should not be flipped
            for i in 0..n {
                if i != n-2 && i != n-1 {
                    assert!(g1.params[i] > 0.0, "Generator 1 should not flip bit {} for n={}", i, n);
                    assert!(g2.params[i] > 0.0, "Generator 2 should not flip bit {} for n={}", i, n);
                }
            }
        }
    }

    /// Test Klein group action on Clifford elements (for resonance preservation)
    #[test]
    fn test_klein_clifford_action() {
        let test_sizes = vec![4, 8, 16];
        
        for n in test_sizes {
            let klein_action = KleinCliffordAction::new(n);
            let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
            
            // Create a test Clifford element with known Klein structure
            let mut test_elem = CliffordElement::<f64>::zero(n);
            
            // Set components that form a Klein orbit
            // For n=8: orbit {0, 64, 128, 192} (flipping bits 6 and 7)
            let base_index = 0;
            let orbit_indices = vec![
                base_index,
                base_index ^ (1 << (n-2)),
                base_index ^ (1 << (n-1)),
                base_index ^ (1 << (n-2)) ^ (1 << (n-1)),
            ];
            
            // Set equal coefficients for Klein orbit
            for &idx in &orbit_indices {
                if idx < test_elem.num_components() {
                    test_elem.set_component(idx, num_complex::Complex::new(0.5, 0.0)).unwrap();
                }
            }
            
            // Test that Klein action preserves structure
            for g in group.generators() {
                assert!(klein_action.verify_invariance(g),
                    "Klein action should preserve invariants for n={}", n);
                
                let transformed = klein_action.apply(g, &test_elem).unwrap();
                
                // Check that norm is preserved
                let norm_before = test_elem.coherence_norm();
                let norm_after = transformed.coherence_norm();
                assert!((norm_before - norm_after).abs() < 1e-10,
                    "Klein action should preserve norm for n={}: {} vs {}", n, norm_before, norm_after);
            }
        }
    }

    /// Test Klein group is abelian (all elements commute)
    #[test]
    fn test_klein_is_abelian() {
        let test_sizes = vec![3, 8, 16, 32, 64];
        
        for n in test_sizes {
            let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
            
            // Get all 4 Klein elements
            let identity = group.identity();
            let g1 = group.generators()[0].clone();
            let g2 = group.generators()[1].clone();
            let g12 = group.multiply(&g1, &g2).unwrap();
            
            let elements = vec![identity, g1.clone(), g2.clone(), g12.clone()];
            
            // Test all pairs commute
            for i in 0..4 {
                for j in 0..4 {
                    let ab = group.multiply(&elements[i], &elements[j]).unwrap();
                    let ba = group.multiply(&elements[j], &elements[i]).unwrap();
                    
                    // Check if ab = ba
                    let commute = ab.params.iter().zip(&ba.params)
                        .all(|(a, b)| (a - b).abs() < f64::EPSILON);
                    
                    assert!(commute, "Klein group elements should commute for n={}", n);
                }
            }
        }
    }

    /// Test Klein subgroup structure V₄ = {e, a, b, ab}
    #[test]
    fn test_klein_v4_structure() {
        let n = 8;
        let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
        
        let e = group.identity();
        let a = group.generators()[0].clone();
        let b = group.generators()[1].clone();
        let ab = group.multiply(&a, &b).unwrap();
        
        // Verify a² = e
        let a_squared = group.multiply(&a, &a).unwrap();
        assert!(a_squared.is_identity(), "a² should equal identity");
        
        // Verify b² = e
        let b_squared = group.multiply(&b, &b).unwrap();
        assert!(b_squared.is_identity(), "b² should equal identity");
        
        // Verify (ab)² = e
        let ab_squared = group.multiply(&ab, &ab).unwrap();
        assert!(ab_squared.is_identity(), "(ab)² should equal identity");
        
        // Verify ab = ba (commutativity)
        let ba = group.multiply(&b, &a).unwrap();
        let equal = ab.params.iter().zip(&ba.params)
            .all(|(x, y)| (x - y).abs() < f64::EPSILON);
        assert!(equal, "ab should equal ba (Klein group is abelian)");
    }
}

#[cfg(test)]
mod resonance_preservation_tests {
    use super::*;

    /// Test resonance preservation for bit lengths 3-4096 (extended range)
    #[test]
    fn test_resonance_preservation_extended_range() {
        // Test key bit lengths from BJC spec and beyond
        let test_sizes = vec![3, 4, 8, 10, 16, 32, 53, 64, 128, 256, 512, 1024, 2048, 4096];
        
        for n in test_sizes {
            // Skip very large sizes in CI
            if n > 256 && std::env::var("CI").is_ok() {
                continue;
            }
            let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
            let alpha = AlphaVec::<f64>::mathematical(n).unwrap();
            
            // Create test element with Klein-symmetric structure
            let mut test_elem = CliffordElement::<f64>::zero(n);
            
            // Add components in complete Klein orbits
            let orbits = vec![0, 1, 2]; // Test first few orbits
            for base in orbits {
                if base < (1 << (n-2)) {
                    let indices = vec![
                        base,
                        base | (1 << (n-2)),
                        base | (1 << (n-1)),
                        base | (1 << (n-2)) | (1 << (n-1)),
                    ];
                    
                    for idx in indices {
                        if idx < test_elem.num_components() {
                            test_elem.set_component(idx, num_complex::Complex::new(0.25, 0.0)).unwrap();
                        }
                    }
                }
            }
            
            // Test with Klein action (which preserves resonance)
            let action = KleinCliffordAction::new(n);
            
            // Verify resonance is preserved
            assert!(
                verify_resonance_preservation(&group, &test_elem, &action),
                "Resonance should be preserved by Klein group for n={}", n
            );
            
            // Test specific resonance invariants
            let invariant = ResonanceInvariant;
            assert!(
                invariant.is_invariant(&group),
                "Klein group should preserve resonance invariants for n={}", n
            );
        }
    }

    /// Test that Klein orbits are correctly computed
    #[test]
    fn test_klein_orbit_structure() {
        let test_cases = vec![
            (3, vec![0b000, 0b010, 0b100, 0b110]),
            (4, vec![0b0000, 0b0100, 0b1000, 0b1100]),
            (8, vec![0b00000000, 0b01000000, 0b10000000, 0b11000000]),
        ];
        
        for (n, expected_orbit) in test_cases {
            let b = BitWord::from_u64(expected_orbit[0], n);
            let members = <BitWord as Resonance<f64>>::class_members(&b);
            
            // Check we get exactly 4 members
            assert_eq!(members.len(), 4, "Klein orbit should have 4 members for n={}", n);
            
            // Check the orbit matches expected values
            let member_vals: Vec<u64> = members.iter()
                .map(|m| m.to_usize() as u64)
                .collect();
            
            for expected in expected_orbit {
                assert!(
                    member_vals.contains(&expected),
                    "Klein orbit missing expected member {} for n={}",
                    expected, n
                );
            }
        }
    }

    /// Test resonance conservation over 768-cycle
    #[test]
    fn test_resonance_768_cycle_conservation() {
        // For small n where we can compute the full cycle
        let n = 8;
        let alpha = AlphaVec::<f64>::mathematical(n).unwrap();
        
        // Compute sum over full cycle (256 values for n=8, repeated 3 times for 768)
        let mut cycle_sum = 0.0;
        for i in 0..768 {
            let word = BitWord::from_u64((i % 256) as u64, n);
            cycle_sum += word.r(&alpha);
        }
        
        // The sum should be close to the theoretical value
        let expected = 687.110133051847;
        let relative_error = (cycle_sum - expected).abs() / expected;
        
        // Allow for some numerical error accumulation
        assert!(
            relative_error < 1e-6,
            "768-cycle sum should be conserved: got {} vs expected {}, error: {}",
            cycle_sum, expected, relative_error
        );
    }
}

#[cfg(test)]
mod bjc_minimum_tests {
    use super::*;

    /// Test Klein minimum finding (argmin |R(x)| over unity class) for extended bit ranges
    #[test]
    fn test_klein_minimum_finding_extended() {
        let test_sizes = vec![3, 4, 8, 16, 32, 64, 128, 256, 512, 1024];
        
        for n in test_sizes {
            // Skip very large sizes in CI
            if n > 256 && std::env::var("CI").is_ok() {
                continue;
            }
            let alpha = AlphaVec::<f64>::mathematical(n).unwrap();
            
            // Test various bit patterns
            let test_values = vec![0, 1, 15, 42, 255];
            
            for &val in &test_values {
                if val < (1 << n) {
                    let b = BitWord::from_u64(val as u64, n);
                    
                    // Get Klein orbit members
                    let members = <BitWord as Resonance<f64>>::class_members(&b);
                    assert_eq!(members.len(), 4, "Klein orbit should have 4 members");
                    
                    // Find minimum resonance
                    let resonances: Vec<(f64, &BitWord)> = members.iter()
                        .map(|m| (m.r(&alpha), m))
                        .collect();
                    
                    let (r_min, b_min) = resonances.iter()
                        .min_by(|a, b| a.0.partial_cmp(&b.0).unwrap())
                        .unwrap();
                    
                    // Verify it's actually the minimum
                    for (r, _) in &resonances {
                        assert!(
                            r >= r_min,
                            "Found non-minimal resonance in Klein orbit for n={}, val={}",
                            n, val
                        );
                    }
                    
                    // Check is_klein_minimum method
                    assert!(
                        b_min.is_klein_minimum(&alpha),
                        "Minimum element should be identified as Klein minimum"
                    );
                }
            }
        }
    }

    /// Test tie-breaking by smallest integer (as per BJC spec)
    #[test]
    fn test_klein_minimum_tiebreak() {
        // In case of equal resonances, choose smallest integer
        // This can happen with specially crafted alpha values
        
        let n = 4;
        // Create alpha where some Klein orbit members have equal resonance
        let mut alpha_values = vec![1.0; n];
        alpha_values[n-2] = 1.0;
        alpha_values[n-1] = 1.0; // Unity constraint satisfied
        let alpha = AlphaVec::new(alpha_values.into_boxed_slice()).unwrap();
        
        let b = BitWord::from_u64(0b1111, n);
        let members = <BitWord as Resonance<f64>>::class_members(&b);
        
        // With all alphas = 1, all resonances are equal
        let resonances: Vec<_> = members.iter()
            .map(|m| (m.r(&alpha), m.to_usize() as u64))
            .collect();
        
        // All should have same resonance
        let r0: f64 = resonances[0].0;
        for (r, _) in &resonances {
            let r: f64 = *r;
            assert!((r - r0).abs() < 1e-10, "All Klein members should have equal resonance");
        }
        
        // Minimum should be the one with smallest integer value
        let min_val = resonances.iter()
            .map(|(_, val)| val)
            .min()
            .unwrap();
        
        let expected_min = BitWord::from_u64(*min_val, n);
        assert!(expected_min.is_klein_minimum(&alpha), "Smallest integer should be Klein minimum on tie");
    }
}

#[cfg(test)]
mod flip_bit_tests {
    use super::*;

    /// Test flip bit operations on positions n-2 and n-1
    #[test]
    fn test_flip_bit_operations() {
        let test_sizes = vec![3, 4, 8, 16, 32, 64];
        
        for n in test_sizes {
            let action = BitWordAction::new(n);
            
            // Create flip elements
            let flip_n2 = GroupElement::<f64>::from_bit_flip(n-2, n);
            let flip_n1 = GroupElement::<f64>::from_bit_flip(n-1, n);
            
            // Test on various bit patterns
            let test_values = vec![0, 1, (1 << (n-2)) - 1, (1 << n) - 1];
            
            for &val in &test_values {
                if val < (1 << n) {
                    let b = BitWord::from_u64(val as u64, n);
                    
                    // Apply flips
                    let b_flip_n2 = action.apply(&flip_n2, &b).unwrap();
                    let b_flip_n1 = action.apply(&flip_n1, &b).unwrap();
                    
                    // Verify correct bits were flipped
                    for i in 0..n {
                        if i == n-2 {
                            assert_ne!(b.bit(i), b_flip_n2.bit(i), "Bit {} should be flipped", i);
                            assert_eq!(b.bit(i), b_flip_n1.bit(i), "Bit {} should not be flipped", i);
                        } else if i == n-1 {
                            assert_eq!(b.bit(i), b_flip_n2.bit(i), "Bit {} should not be flipped", i);
                            assert_ne!(b.bit(i), b_flip_n1.bit(i), "Bit {} should be flipped", i);
                        } else {
                            assert_eq!(b.bit(i), b_flip_n2.bit(i), "Bit {} should not be flipped", i);
                            assert_eq!(b.bit(i), b_flip_n1.bit(i), "Bit {} should not be flipped", i);
                        }
                    }
                }
            }
        }
    }

    /// Test that flip operations are involutions (self-inverse)
    #[test]
    fn test_flip_involution() {
        let n = 8;
        let action = BitWordAction::new(n);
        let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
        
        let test_word = BitWord::from_u64(0b10101010, n);
        
        for g in group.generators() {
            // Apply twice should give identity
            let once = action.apply(g, &test_word).unwrap();
            let twice = action.apply(g, &once).unwrap();
            
            assert_eq!(
                test_word, twice,
                "Applying flip twice should return to original"
            );
        }
    }
}

#[cfg(test)]
mod systematic_tests {
    use super::*;

    /// Systematically test Klein class properties for all n in [3,64]
    #[test]
    fn test_klein_class_properties_systematic() {
        // Test representative values for each bit length
        let test_cases = vec![
            (3, vec![0, 1, 7]),
            (4, vec![0, 1, 5, 15]),
            (8, vec![0, 1, 42, 128, 255]),
            (16, vec![0, 1, 256, 1024, 65535]),
            (32, vec![0, 1, 1000000, u32::MAX as u64]),
            (64, vec![0, 1, 1_000_000_000_000]),
        ];
        
        for (n, test_values) in test_cases {
            for &val in &test_values {
                if val < (1u64 << n) {
                    let b = BitWord::from_u64(val, n);
                    let members = <BitWord as Resonance<f64>>::class_members(&b);
                    
                    // Klein class should always have exactly 4 members
                    assert_eq!(members.len(), 4, "Klein class size for n={}, val={}", n, val);
                    
                    // All members should be distinct
                    let unique: std::collections::HashSet<_> = members.iter().collect();
                    assert_eq!(unique.len(), 4, "Klein class uniqueness for n={}, val={}", n, val);
                    
                    // All should differ only in last 2 bits
                    let mask = !((1u64 << (n-2)) | (1u64 << (n-1)));
                    let base = val & mask;
                    
                    for member in &members {
                        let member_val = member.to_usize() as u64;
                        assert_eq!(member_val & mask, base,
                            "Klein member differs in non-unity bits for n={}, val={}", n, val);
                    }
                }
            }
        }
    }

    /// Test Klein class membership systematically
    #[test]
    fn test_klein_class_membership_systematic() {
        // Test smaller n values for complete coverage
        for n in 3..=20 {
            // Test several values per bit length
            let step = if n <= 8 { 1 } else { 1 << (n-4) };
            let mut val = 0u64;
            
            while val < (1u64 << n) {
                let b = BitWord::from_u64(val, n);
                let members = <BitWord as Resonance<f64>>::class_members(&b);
                
                // Verify Klein class properties
                assert_eq!(members.len(), 4, "Klein class should have 4 members");
                
                // All members should differ only in bits n-2 and n-1
                let mask = !((1u64 << (n-2)) | (1u64 << (n-1)));
                let base = val & mask;
                
                for member in &members {
                    let member_val = member.to_usize() as u64;
                    let member_base = member_val & mask;
                    assert_eq!(member_base, base,
                        "Klein member differs in non-unity bits for n={}, val={}",
                        n, val
                    );
                }
                
                // Check that original value is in the orbit
                let vals: Vec<u64> = members.iter()
                    .map(|m| m.to_usize() as u64)
                    .collect();
                assert!(vals.contains(&val),
                    "Original value {} not in its Klein orbit for n={}", val, n);
                
                val += step;
            }
        }
    }

    /// Test Klein group closure systematically
    #[test]
    fn test_klein_group_closure_systematic() {
        for n in vec![3, 4, 8, 16] {
            let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
            
            // Get all group elements
            let e = group.identity();
            let a = group.generators()[0].clone();
            let b = group.generators()[1].clone();
            let ab = group.multiply(&a, &b).unwrap();
            
            let elements = vec![e.clone(), a.clone(), b.clone(), ab.clone()];
            
            // Test closure: product of any two elements is in the group
            for i in 0..4 {
                for j in 0..4 {
                    let product = group.multiply(&elements[i], &elements[j]).unwrap();
                    
                    // Product should equal one of the 4 elements
                    let found = elements.iter().any(|elem| {
                        elem.params.iter().zip(&product.params)
                            .all(|(x, y)| (x - y).abs() < f64::EPSILON)
                    });
                    
                    assert!(found,
                        "Klein group not closed under multiplication for n={}, i={}, j={}",
                        n, i, j
                    );
                }
            }
        }
    }
}

#[cfg(test)]
mod large_scale_tests {
    use super::*;

    /// Test bijectivity for large bit sizes (up to 4096 bits)
    #[test]
    #[ignore] // Run with --ignored flag for extended testing
    fn test_bijectivity_large_scale() {
        let test_sizes = vec![512, 1024, 2048, 4096];
        
        for n in test_sizes {
            println!("\nTesting bijectivity for n={} bits", n);
            
            // For large n, we can't test all values, so sample strategically
            let mut test_patterns = Vec::new();
            
            // Edge cases
            test_patterns.push(vec![0u8; (n + 7) / 8]); // All zeros
            test_patterns.push(vec![0xFFu8; (n + 7) / 8]); // All ones
            
            // Patterns with specific bits set
            for i in 0..n.min(64) {
                let mut pattern = vec![0u8; (n + 7) / 8];
                pattern[i / 8] |= 1 << (i % 8);
                test_patterns.push(pattern);
            }
            
            // Random patterns
            use std::collections::hash_map::DefaultHasher;
            use std::hash::{Hash, Hasher};
            for i in 0..1000 {
                let mut pattern = vec![0u8; (n + 7) / 8];
                for j in 0..pattern.len() {
                    let mut hasher = DefaultHasher::new();
                    (i, j, n).hash(&mut hasher);
                    pattern[j] = (hasher.finish() & 0xFF) as u8;
                }
                test_patterns.push(pattern);
            }
            
            // Test bijectivity
            let mut klein_map = std::collections::HashMap::new();
            
            for pattern in &test_patterns {
                let mut b = BitWord::new(n);
                // Set bits from pattern bytes
                for (i, &byte) in pattern.iter().enumerate() {
                    for bit in 0..8 {
                        let bit_idx = i * 8 + bit;
                        if bit_idx < n && (byte >> bit) & 1 == 1 {
                            b.set_bit(bit_idx, true);
                        }
                    }
                }
                let members = <BitWord as Resonance<f64>>::class_members(&b);
                
                assert_eq!(members.len(), 4, "Klein class should have 4 members for n={}", n);
                
                // Find Klein minimum
                let alpha = AlphaVec::<f64>::mathematical(n).unwrap();
                let (b_min, _) = members.iter()
                    .map(|m| (m.clone(), m.r(&alpha)))
                    .min_by(|(b1, r1), (b2, r2)| {
                        match r1.partial_cmp(r2).unwrap() {
                            std::cmp::Ordering::Equal => {
                                // Compare bit by bit for tie-breaking
                                for i in 0..n {
                                    match (b1.bit(i), b2.bit(i)) {
                                        (false, true) => return std::cmp::Ordering::Less,
                                        (true, false) => return std::cmp::Ordering::Greater,
                                        _ => continue,
                                    }
                                }
                                std::cmp::Ordering::Equal
                            },
                            other => other,
                        }
                    })
                    .unwrap();
                
                // Verify we can reconstruct original from minimum + flip bits
                let flip_n2 = b.bit(n-2) != b_min.bit(n-2);
                let flip_n1 = b.bit(n-1) != b_min.bit(n-1);
                
                let mut reconstructed = b_min.clone();
                if flip_n2 {
                    reconstructed.flip_bit(n-2);
                }
                if flip_n1 {
                    reconstructed.flip_bit(n-1);
                }
                
                assert_eq!(reconstructed, b,
                    "Failed to reconstruct original from Klein minimum for n={}", n);
                
                // Check uniqueness of Klein minimum mapping
                let min_key = (0..n).map(|i| if b_min.bit(i) { 1u8 } else { 0u8 }).collect::<Vec<_>>();
                klein_map.entry(min_key)
                    .and_modify(|count| *count += 1)
                    .or_insert(1);
            }
            
            // All Klein minima should be unique (or map to same orbit)
            let unique_minima = klein_map.len();
            println!("Found {} unique Klein minima for {} test patterns", 
                unique_minima, test_patterns.len());
        }
    }

    /// Test numerical stability for large n
    #[test]
    #[ignore]
    fn test_numerical_stability_large_n() {
        let test_sizes = vec![64, 128, 256, 512, 1024];
        
        for n in test_sizes {
            let alpha = AlphaVec::<f64>::mathematical(n).unwrap();
            
            // Test that resonance calculations don't overflow/underflow
            let test_patterns = vec![
                vec![0u8; (n + 7) / 8],      // All zeros
                vec![0xFFu8; (n + 7) / 8],   // All ones
            ];
            
            for pattern in &test_patterns {
                let mut b = BitWord::new(n);
                // Set bits from pattern bytes
                for (i, &byte) in pattern.iter().enumerate() {
                    for bit in 0..8 {
                        let bit_idx = i * 8 + bit;
                        if bit_idx < n && (byte >> bit) & 1 == 1 {
                            b.set_bit(bit_idx, true);
                        }
                    }
                }
                let r = b.r(&alpha);
                
                assert!(r.is_finite(), "Resonance should be finite for n={}", n);
                assert!(r > 0.0, "Resonance should be positive for n={}", n);
                
                // Check Klein orbit resonances
                let members = <BitWord as Resonance<f64>>::class_members(&b);
                for member in members {
                    let mr = member.r(&alpha);
                    assert!(mr.is_finite(), "Klein member resonance should be finite for n={}", n);
                    assert!(mr > 0.0, "Klein member resonance should be positive for n={}", n);
                }
            }
            
            println!("Numerical stability verified for n={}", n);
        }
    }
}

#[cfg(test)]
mod benchmark_tests {
    use super::*;
    use std::time::Instant;

    /// Benchmark Klein group operations for codec performance
    #[test]
    fn bench_klein_operations() {
        let sizes = vec![8, 16, 32, 64];
        let iterations = 10000;
        
        println!("\nKlein Group Operation Benchmarks:");
        println!("=================================");
        
        for n in sizes {
            let group = SymmetryGroup::<f64>::klein_group(n).unwrap();
            let action = BitWordAction::new(n);
            let test_word = BitWord::from_u64(0xDEADBEEF, n);
            
            // Benchmark group multiplication
            let start = Instant::now();
            for _ in 0..iterations {
                let a = &group.generators()[0];
                let b = &group.generators()[1];
                let _ = group.multiply(a, b).unwrap();
            }
            let mult_time = start.elapsed();
            
            // Benchmark bit flip action
            let start = Instant::now();
            for _ in 0..iterations {
                let g = &group.generators()[0];
                let _ = action.apply(g, &test_word).unwrap();
            }
            let action_time = start.elapsed();
            
            // Benchmark Klein minimum finding
            let alpha = AlphaVec::<f64>::mathematical(n).unwrap();
            let start = Instant::now();
            for i in 0..iterations {
                let b = BitWord::from_u64(i as u64, n);
                let members = <BitWord as Resonance<f64>>::class_members(&b);
                let _ = members.iter()
                    .min_by_key(|m| (m.r(&alpha) * 1e10) as i64)
                    .unwrap();
            }
            let min_time = start.elapsed();
            
            println!("n = {}:", n);
            println!("  Group multiply: {:?} per op", mult_time / iterations);
            println!("  Bit flip action: {:?} per op", action_time / iterations);
            println!("  Klein minimum: {:?} per op", min_time / iterations);
        }
    }
}