//! CCM Symmetry - Group actions and invariant theory
//!
//! This crate implements Axiom A3 of Coherence-Centric Mathematics:
//! symmetry group actions that preserve CCM structure.

#![cfg_attr(not(feature = "std"), no_std)]
#![warn(missing_docs)]

#[cfg(feature = "alloc")]
extern crate alloc;

// Import core types
use ccm_core::CcmError;

#[cfg(all(feature = "alloc", not(feature = "std")))]
use alloc::string::String;
#[cfg(feature = "std")]
use std::string::String;

use core::fmt;

// Module structure
pub mod actions;
pub mod decomposition;
pub mod discrete;
pub mod group;
pub mod invariants;
pub mod iterator;
pub mod lie_algebra;
pub mod matrix_group;
pub mod orbits;
pub mod polynomial;
pub mod special_subgroups;
pub mod verification;

// Re-export main types
pub use actions::{CliffordAction, GroupAction};
pub use decomposition::{
    SymmetricDecomposition, OrbitComponent, SymmetryBoundary, SymmetryBoundaryType,
};
pub use discrete::{KleinSymmetry, ResonanceAutomorphism};
pub use group::{GroupElement, SymmetryGroup, GroupType, StabilizerSubgroup};
pub use invariants::{ConservedQuantity, Invariant};
pub use iterator::GroupElementIterator;
pub use lie_algebra::{LieAlgebra, LieAlgebraElement};
pub use group::Orbit;
pub use orbits::{compute_orbit, compute_stabilizer, same_orbit, count_orbits};
pub use special_subgroups::{
    grade_preserving_subgroup, klein_subgroup, maximal_resonance_subgroup,
    resonance_preserving_subgroup, unity_stabilizer,
};
pub use verification::{ActionVerifier, CCMInvarianceVerifier, GroupAxiomVerifier};
pub use polynomial::{
    Polynomial, PolynomialRing, Monomial, MonomialOrdering,
    GroebnerBasis, buchberger_algorithm, ReynoldsOperator,
    InvariantRing, PolynomialInvariant,
};

/// Types of symmetries that can be detected and analyzed
///
/// This enumeration provides a standard way to identify symmetries across the CCM ecosystem.
/// It's used by:
/// - Window analysis to record detected symmetries
/// - Decomposition strategies to guide splitting
/// - Conservation laws to identify associated quantities
///
/// # Examples
///
/// ```
/// use ccm_symmetry::SymmetryType;
/// 
/// // Create different symmetry types
/// let translation = SymmetryType::Translation;
/// let klein = SymmetryType::Klein;
/// let cyclic = SymmetryType::Cyclic(5);
/// 
/// // Check properties
/// assert!(translation.is_continuous());
/// assert!(klein.is_discrete());
/// assert_eq!(klein.order(), Some(4));
/// assert!(cyclic.is_abelian());
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum SymmetryType {
    /// Translation symmetry (continuous)
    /// 
    /// Represents invariance under spatial translation.
    /// In CCM, this manifests as shift invariance in byte sequences.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Translation;
    /// assert!(sym.is_continuous());
    /// assert_eq!(sym.order(), None); // Infinite group
    /// ```
    Translation,
    
    /// Rotation symmetry (continuous)
    /// 
    /// Represents invariance under rotation transformations.
    /// In CCM, this appears in phase-invariant operations.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Rotation;
    /// assert!(sym.is_continuous());
    /// assert!(sym.is_abelian());
    /// ```
    Rotation,
    
    /// Reflection symmetry (discrete)
    /// 
    /// Represents invariance under reflection (order 2).
    /// In CCM, this can appear as bit-flip invariance.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Reflection;
    /// assert!(sym.is_discrete());
    /// assert_eq!(sym.order(), Some(2));
    /// ```
    Reflection,
    
    /// Klein four-group symmetry V₄ (discrete)
    /// 
    /// The Klein four-group V₄ = {e, a, b, ab} where a² = b² = (ab)² = e.
    /// In CCM, this is fundamental due to the unity constraint creating
    /// XOR-homomorphic subgroups.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Klein;
    /// assert_eq!(sym.order(), Some(4));
    /// assert!(sym.is_abelian());
    /// ```
    Klein,
    
    /// Cyclic group symmetry Cₙ (discrete)
    /// 
    /// Represents n-fold rotational symmetry.
    /// Generated by a single element of order n.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Cyclic(6);
    /// assert_eq!(sym.order(), Some(6));
    /// assert!(sym.is_abelian()); // All cyclic groups are abelian
    /// ```
    Cyclic(usize),
    
    /// Dihedral group symmetry Dₙ (discrete)
    /// 
    /// Symmetry group of a regular n-gon, including rotations and reflections.
    /// Has order 2n and is non-abelian for n > 2.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Dihedral(4);
    /// assert_eq!(sym.order(), Some(8)); // D₄ has 8 elements
    /// assert!(!sym.is_abelian()); // Non-abelian for n > 2
    /// ```
    Dihedral(usize),
    
    /// Permutation group symmetry Sₙ
    /// 
    /// The symmetric group on n elements.
    /// Has order n! and is non-abelian for n > 2.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Permutation(3);
    /// assert_eq!(sym.order(), Some(6)); // 3! = 6
    /// ```
    Permutation(usize),
    
    /// General linear group symmetry GL(n)
    /// 
    /// Group of invertible linear transformations.
    /// Continuous and non-abelian.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Linear;
    /// assert!(sym.is_continuous());
    /// assert!(!sym.is_abelian());
    /// ```
    Linear,
    
    /// Special orthogonal group symmetry SO(n)
    /// 
    /// Group of rotations (determinant 1 orthogonal transformations).
    /// Continuous and non-abelian for n > 2.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Orthogonal;
    /// assert!(sym.is_continuous());
    /// ```
    Orthogonal,
    
    /// Custom/composite symmetry
    /// 
    /// For domain-specific or composite symmetries not covered above.
    /// 
    /// # Example
    /// ```
    /// # use ccm_symmetry::SymmetryType;
    /// let sym = SymmetryType::Custom("SL(2,Z)".to_string());
    /// assert_eq!(format!("{}", sym), "Custom(SL(2,Z))");
    /// ```
    Custom(String),
}

impl SymmetryType {
    /// Check if this is a discrete symmetry
    pub fn is_discrete(&self) -> bool {
        match self {
            Self::Translation | Self::Rotation | Self::Linear | Self::Orthogonal => false,
            Self::Reflection | Self::Klein | Self::Cyclic(_) | Self::Dihedral(_) | Self::Permutation(_) => true,
            Self::Custom(_) => false, // Unknown, assume continuous
        }
    }
    
    /// Check if this is a continuous symmetry
    pub fn is_continuous(&self) -> bool {
        !self.is_discrete()
    }
    
    /// Get the order of the symmetry group (None for infinite groups)
    pub fn order(&self) -> Option<usize> {
        match self {
            Self::Translation | Self::Rotation | Self::Linear | Self::Orthogonal => None,
            Self::Reflection => Some(2),
            Self::Klein => Some(4),
            Self::Cyclic(n) => Some(*n),
            Self::Dihedral(n) => Some(2 * n),
            Self::Permutation(n) => {
                // Order of S_n is n!
                let mut factorial = 1;
                for i in 1..=*n {
                    factorial *= i;
                }
                Some(factorial)
            },
            Self::Custom(_) => None, // Unknown
        }
    }
    
    /// Check if this is an abelian (commutative) group
    pub fn is_abelian(&self) -> bool {
        match self {
            Self::Translation | Self::Rotation | Self::Cyclic(_) => true,
            Self::Reflection | Self::Klein => true,
            Self::Dihedral(n) => *n <= 2,
            Self::Permutation(n) => *n <= 2,
            Self::Linear | Self::Orthogonal => false,
            Self::Custom(_) => false, // Unknown, assume non-abelian
        }
    }
}

impl fmt::Display for SymmetryType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Translation => write!(f, "Translation"),
            Self::Rotation => write!(f, "Rotation"),
            Self::Reflection => write!(f, "Reflection"),
            Self::Klein => write!(f, "Klein V₄"),
            Self::Cyclic(n) => write!(f, "Cyclic C{}", n),
            Self::Dihedral(n) => write!(f, "Dihedral D{}", n),
            Self::Permutation(n) => write!(f, "Permutation S{}", n),
            Self::Linear => write!(f, "General Linear GL"),
            Self::Orthogonal => write!(f, "Special Orthogonal SO"),
            Self::Custom(name) => write!(f, "Custom({})", name),
        }
    }
}

/// Symmetry-specific error types
#[derive(Debug, Clone, PartialEq)]
pub enum SymmetryError {
    /// Group operation failed
    InvalidGroupOperation,
    /// Element not in group
    NotInGroup,
    /// Action does not preserve structure
    InvarianceViolation,
    /// Lie algebra operation failed
    LieAlgebraError,
    /// Orbit computation failed
    OrbitComputationFailed,
}

impl From<SymmetryError> for CcmError {
    fn from(err: SymmetryError) -> Self {
        match err {
            SymmetryError::InvalidGroupOperation => CcmError::InvalidInput,
            SymmetryError::NotInGroup => CcmError::InvalidInput,
            SymmetryError::InvarianceViolation => CcmError::Custom("Invariance violation"),
            SymmetryError::LieAlgebraError => CcmError::Custom("Lie algebra error"),
            SymmetryError::OrbitComputationFailed => CcmError::Custom("Orbit computation failed"),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_symmetry_group_creation() {
        let _group = SymmetryGroup::<f64>::generate(8).unwrap();
        // Group was created successfully for dimension 8
    }
    
    #[test]
    fn test_symmetry_type_discrete() {
        // Test discrete symmetries
        assert!(SymmetryType::Reflection.is_discrete());
        assert!(SymmetryType::Klein.is_discrete());
        assert!(SymmetryType::Cyclic(5).is_discrete());
        assert!(SymmetryType::Dihedral(4).is_discrete());
        assert!(SymmetryType::Permutation(3).is_discrete());
        
        // Test continuous symmetries
        assert!(!SymmetryType::Translation.is_discrete());
        assert!(!SymmetryType::Rotation.is_discrete());
        assert!(!SymmetryType::Linear.is_discrete());
        assert!(!SymmetryType::Orthogonal.is_discrete());
        
        // Test is_continuous method
        assert!(SymmetryType::Translation.is_continuous());
        assert!(SymmetryType::Rotation.is_continuous());
        assert!(!SymmetryType::Klein.is_continuous());
    }
    
    #[test]
    fn test_symmetry_type_order() {
        // Finite groups
        assert_eq!(SymmetryType::Reflection.order(), Some(2));
        assert_eq!(SymmetryType::Klein.order(), Some(4));
        assert_eq!(SymmetryType::Cyclic(5).order(), Some(5));
        assert_eq!(SymmetryType::Dihedral(3).order(), Some(6));
        assert_eq!(SymmetryType::Permutation(3).order(), Some(6)); // 3! = 6
        assert_eq!(SymmetryType::Permutation(4).order(), Some(24)); // 4! = 24
        
        // Infinite groups
        assert_eq!(SymmetryType::Translation.order(), None);
        assert_eq!(SymmetryType::Rotation.order(), None);
        assert_eq!(SymmetryType::Linear.order(), None);
        assert_eq!(SymmetryType::Orthogonal.order(), None);
        assert_eq!(SymmetryType::Custom("test".into()).order(), None);
    }
    
    #[test]
    fn test_symmetry_type_abelian() {
        // Abelian groups
        assert!(SymmetryType::Translation.is_abelian());
        assert!(SymmetryType::Rotation.is_abelian());
        assert!(SymmetryType::Reflection.is_abelian());
        assert!(SymmetryType::Klein.is_abelian());
        assert!(SymmetryType::Cyclic(5).is_abelian());
        assert!(SymmetryType::Dihedral(1).is_abelian());
        assert!(SymmetryType::Dihedral(2).is_abelian());
        assert!(SymmetryType::Permutation(1).is_abelian());
        assert!(SymmetryType::Permutation(2).is_abelian());
        
        // Non-abelian groups
        assert!(!SymmetryType::Dihedral(3).is_abelian());
        assert!(!SymmetryType::Permutation(3).is_abelian());
        assert!(!SymmetryType::Linear.is_abelian());
        assert!(!SymmetryType::Orthogonal.is_abelian());
    }
    
    #[test]
    fn test_symmetry_type_display() {
        assert_eq!(format!("{}", SymmetryType::Translation), "Translation");
        assert_eq!(format!("{}", SymmetryType::Klein), "Klein V₄");
        assert_eq!(format!("{}", SymmetryType::Cyclic(5)), "Cyclic C5");
        assert_eq!(format!("{}", SymmetryType::Dihedral(4)), "Dihedral D4");
        assert_eq!(format!("{}", SymmetryType::Permutation(3)), "Permutation S3");
        assert_eq!(format!("{}", SymmetryType::Custom("MyGroup".into())), "Custom(MyGroup)");
    }
    
    #[test]
    fn test_symmetry_type_equality() {
        assert_eq!(SymmetryType::Klein, SymmetryType::Klein);
        assert_eq!(SymmetryType::Cyclic(5), SymmetryType::Cyclic(5));
        assert_ne!(SymmetryType::Cyclic(5), SymmetryType::Cyclic(6));
        assert_ne!(SymmetryType::Translation, SymmetryType::Rotation);
    }
}
