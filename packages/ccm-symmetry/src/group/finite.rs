//! Finite group implementations
//! 
//! This module handles groups with finitely many elements such as:
//! - Klein four-group V₄
//! - Cyclic groups Cₙ
//! - Symmetric groups Sₙ
//! - Dihedral groups Dₙ

use num_traits::Float;
use crate::group::{GroupElement, SymmetryGroup, GroupType};
use crate::SymmetryError;
use ccm_core::CcmError;

/// Trait for finite group operations
pub trait FiniteGroup<P: Float> {
    /// Get all elements of the group
    fn elements(&self) -> &[GroupElement<P>];
    
    /// Check if group is abelian (commutative)
    fn is_abelian(&self) -> bool;
    
    /// Find the order of an element
    fn element_order(&self, element: &GroupElement<P>) -> usize;
}

impl<P: Float> FiniteGroup<P> for SymmetryGroup<P> {
    /// Get all elements of the group
    fn elements(&self) -> &[GroupElement<P>] {
        match &self.group_type {
            GroupType::Finite { elements } => elements,
            _ => &[],
        }
    }
    
    /// Check if group is abelian (commutative)
    fn is_abelian(&self) -> bool {
        match &self.group_type {
            GroupType::Finite { elements } => {
                // Check if all elements commute
                for i in 0..elements.len() {
                    for j in i+1..elements.len() {
                        if let (Ok(ab), Ok(ba)) = (
                            self.multiply(&elements[i], &elements[j]),
                            self.multiply(&elements[j], &elements[i])
                        ) {
                            // Check if ab = ba
                            let commute = ab.params.iter().zip(&ba.params)
                                .all(|(a, b)| (*a - *b).abs() < P::epsilon());
                            if !commute {
                                return false;
                            }
                        }
                    }
                }
                true
            }
            _ => false,
        }
    }
    
    /// Find the order of an element
    fn element_order(&self, element: &GroupElement<P>) -> usize {
        if let Some(order) = element.cached_order {
            return order;
        }
        
        // Compute order by repeated multiplication
        let mut current = element.clone();
        let mut order = 1;
        let identity = self.identity();
        
        // Maximum possible order is the group order
        let max_order = self.order().unwrap_or(1000);
        
        while order <= max_order {
            if current.params.iter().zip(&identity.params)
                .all(|(a, b)| (*a - *b).abs() < P::epsilon()) {
                return order;
            }
            
            if let Ok(next) = self.multiply(&current, element) {
                current = next;
                order += 1;
            } else {
                break;
            }
        }
        
        1 // Default to 1 if we can't determine
    }
}

impl<P: Float> SymmetryGroup<P> {
    /// Generate Klein four-group for n-bit system
    /// 
    /// The Klein group V₄ is fundamental to CCM due to the unity constraint.
    /// It acts by XOR on the last two bit positions (n-2, n-1).
    pub fn klein_group(n: usize) -> Result<Self, CcmError> {
        if n < 2 {
            return Err(SymmetryError::InvalidGroupOperation.into());
        }
        
        let mut group = Self::generate(n)?;
        
        // V₄ = {e, a, b, ab} where a² = b² = (ab)² = e
        // In CCM: generated by bit flips on positions n-2, n-1
        let identity = GroupElement::<P>::identity(n);
        let a = GroupElement::<P>::from_bit_flip(n - 2, n);
        let b = GroupElement::<P>::from_bit_flip(n - 1, n);
        
        // Compute ab by XOR multiplication
        let mut ab = a.clone();
        // Flip bit n-1 in ab (since a flips n-2, we add flip of n-1)
        ab.params[n - 1] = -ab.params[n - 1];
        ab.cached_order = Some(2);
        
        group.generators = vec![a.clone(), b.clone()];
        group.group_type = GroupType::Finite {
            elements: vec![identity, a, b, ab],
        };
        group.cached_order = Some(4);
        
        Ok(group)
    }
    
    /// Generate cyclic group C_n
    /// 
    /// The cyclic group of order n is generated by a single element
    /// that cycles through n states before returning to identity.
    pub fn cyclic_group(n: usize, dimension: usize) -> Result<Self, CcmError> {
        if n == 0 || dimension == 0 {
            return Err(SymmetryError::InvalidGroupOperation.into());
        }
        
        let mut group = Self::generate(dimension)?;
        
        // Generate the cyclic permutation that shifts positions
        let generator = GroupElement::cyclic_shift(1, dimension);
        
        // Generate all powers of the generator
        let mut elements = vec![GroupElement::identity(dimension)];
        let mut current = generator.clone();
        
        for _ in 1..n {
            elements.push(current.clone());
            current = group.multiply(&current, &generator)?;
            
            // If we've cycled back to identity early, adjust n
            if current.is_identity() {
                break;
            }
        }
        
        group.generators = vec![generator];
        group.group_type = GroupType::Finite { elements };
        group.cached_order = Some(n);
        
        Ok(group)
    }
    
    /// Generate dihedral group D_n
    /// 
    /// The dihedral group of order 2n is the symmetry group of a regular n-gon.
    /// It has n rotations and n reflections.
    pub fn dihedral_group(n: usize, dimension: usize) -> Result<Self, CcmError> {
        if n == 0 || dimension == 0 {
            return Err(SymmetryError::InvalidGroupOperation.into());
        }
        
        let mut group = Self::generate(dimension)?;
        
        // Generator r: rotation by 2π/n
        let rotation = GroupElement::cyclic_shift(1, dimension.min(n));
        
        // Generator s: reflection (flip first position)
        let reflection = GroupElement::from_bit_flip(0, dimension);
        
        // Generate all elements: r^i and r^i * s for i = 0..n-1
        let mut elements = Vec::with_capacity(2 * n);
        
        // Add rotations
        elements.push(GroupElement::identity(dimension));
        let mut current_rotation = rotation.clone();
        for _ in 1..n {
            elements.push(current_rotation.clone());
            current_rotation = group.multiply(&current_rotation, &rotation)?;
        }
        
        // Add reflections (r^i * s)
        for i in 0..n {
            let reflected = group.multiply(&elements[i], &reflection)?;
            elements.push(reflected);
        }
        
        group.generators = vec![rotation, reflection];
        group.group_type = GroupType::Finite { elements };
        group.cached_order = Some(2 * n);
        
        Ok(group)
    }
}