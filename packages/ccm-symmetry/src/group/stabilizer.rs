//! Stabilizer subgroup computation
//! 
//! The stabilizer of x under G is:
//! Stab_G(x) = {g ∈ G : g·x = x}
//! 
//! This module provides stabilizer computation for all group types.

use num_traits::Float;
use crate::group::{GroupElement, SymmetryGroup, StabilizerSubgroup, GroupType};
use crate::actions::GroupAction;
use crate::iterator::GroupElementIterator;
use crate::SymmetryError;
use ccm_core::CcmError;

/// Trait for computing stabilizer subgroups
pub trait StabilizerComputation<P: Float> {
    /// Compute the stabilizer of an element
    fn compute_stabilizer<T: Clone + PartialEq>(
        &self,
        element: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> StabilizerSubgroup<P>;
    
    /// Compute generators of the stabilizer
    fn compute_stabilizer_generators<T: Clone + PartialEq>(
        &self,
        element: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<GroupElement<P>>;
    
    /// Minimize stabilizer generators
    fn minimize_stabilizer_generators(
        &self,
        generators: Vec<GroupElement<P>>,
    ) -> StabilizerSubgroup<P>;
}

impl<P: Float> SymmetryGroup<P> {
    /// Compute the stabilizer subgroup of an element
    /// 
    /// The stabilizer is the subgroup of elements that fix the given element
    pub fn stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> StabilizerSubgroup<P> {
        let mut stabilizer_generators = Vec::new();
        
        match &self.group_type {
            GroupType::Finite { elements } => {
                // For finite groups, check which elements fix x
                for g in elements {
                    if let Ok(transformed) = action.apply(g, x) {
                        if transformed == *x && !g.is_identity() {
                            stabilizer_generators.push(g.clone());
                        }
                    }
                }
            }
            GroupType::DiscreteInfinite => {
                // For discrete infinite groups, solve g·x = x systematically
                stabilizer_generators = self.compute_discrete_infinite_stabilizer(x, action);
            }
            GroupType::Continuous => {
                // For continuous groups, use Lie algebra methods
                stabilizer_generators = self.compute_continuous_stabilizer(x, action);
            }
        }
        
        // Minimize the generator set
        self.minimize_stabilizer_generators(stabilizer_generators)
    }
    
    /// Minimize a set of stabilizer generators
    /// 
    /// This removes redundant generators to find a minimal generating set
    fn minimize_stabilizer_generators(
        &self,
        generators: Vec<GroupElement<P>>,
    ) -> StabilizerSubgroup<P> {
        if generators.is_empty() {
            return StabilizerSubgroup {
                generators: Vec::new(),
            };
        }
        
        // First, remove duplicates
        let mut unique_gens = Vec::new();
        for gen in generators {
            let is_duplicate = unique_gens.iter().any(|g: &GroupElement<P>| {
                self.elements_equal(g, &gen)
            });
            
            if !is_duplicate && !gen.is_identity() {
                unique_gens.push(gen);
            }
        }
        
        // Now minimize the generating set
        let minimal = match &self.group_type {
            GroupType::Finite { .. } => {
                self.minimize_finite_generators(unique_gens)
            }
            GroupType::DiscreteInfinite => {
                self.minimize_discrete_generators(unique_gens)
            }
            GroupType::Continuous => {
                self.minimize_continuous_generators(unique_gens)
            }
        };
        
        StabilizerSubgroup {
            generators: minimal,
        }
    }
    
    
    /// Minimize generators for finite groups
    fn minimize_finite_generators(&self, generators: Vec<GroupElement<P>>) -> Vec<GroupElement<P>> {
        let mut minimal = Vec::new();
        let mut generated_so_far = vec![self.identity()];
        
        // Greedy algorithm: add generators that increase the generated subgroup
        for gen in generators {
            // Check if gen is already in the subgroup generated by minimal
            if !self.is_in_subgroup(&gen, &generated_so_far) {
                minimal.push(gen.clone());
                
                // Update generated_so_far with new elements
                let mut new_elements = Vec::new();
                for g in &generated_so_far {
                    if let Ok(product) = self.multiply(g, &gen) {
                        if !self.is_in_subgroup(&product, &generated_so_far) {
                            new_elements.push(product);
                        }
                    }
                    if let Ok(inv_gen) = self.inverse(&gen) {
                        if let Ok(product) = self.multiply(g, &inv_gen) {
                            if !self.is_in_subgroup(&product, &generated_so_far) {
                                new_elements.push(product);
                            }
                        }
                    }
                }
                generated_so_far.extend(new_elements);
            }
        }
        
        minimal
    }
    
    /// Minimize generators for discrete infinite groups
    fn minimize_discrete_generators(&self, generators: Vec<GroupElement<P>>) -> Vec<GroupElement<P>> {
        // For discrete infinite groups, use different strategies based on type
        
        // Check if we have a free abelian group (Z^n)
        if self.is_free_abelian() && generators.len() > 1 {
            return self.minimize_free_abelian_generators(generators);
        }
        
        // For general discrete groups, use redundancy elimination
        let mut minimal = Vec::new();
        
        for (i, gen) in generators.iter().enumerate() {
            // Check if gen can be expressed using other generators
            let others: Vec<_> = generators.iter().enumerate()
                .filter(|(j, _)| *j != i)
                .map(|(_, g)| g.clone())
                .collect();
            
            if others.is_empty() || !self.can_express_with_generators(gen, &others) {
                minimal.push(gen.clone());
            }
        }
        
        minimal
    }
    
    /// Minimize generators for continuous groups
    fn minimize_continuous_generators(&self, generators: Vec<GroupElement<P>>) -> Vec<GroupElement<P>> {
        // For continuous groups, minimize the Lie algebra generators
        
        // Convert to Lie algebra elements
        let lie_elements: Vec<Vec<P>> = generators.iter()
            .map(|gen| {
                gen.params.iter()
                    .zip(self.identity().params.iter())
                    .map(|(g, e)| *g - *e)
                    .collect()
            })
            .collect();
        
        // Find linearly independent subset
        let independent_indices = self.find_linearly_independent(&lie_elements);
        
        // Return corresponding group elements
        independent_indices.into_iter()
            .map(|i| generators[i].clone())
            .collect()
    }
    
    /// Check if element is in the subgroup
    fn is_in_subgroup(&self, element: &GroupElement<P>, subgroup: &[GroupElement<P>]) -> bool {
        subgroup.iter().any(|g| self.elements_equal(g, element))
    }
    
    /// Minimize generators for free abelian groups (Z^n)
    fn minimize_free_abelian_generators(&self, generators: Vec<GroupElement<P>>) -> Vec<GroupElement<P>> {
        // For Z^n, we want to find a basis
        // Use Hermite normal form or similar
        
        if generators.is_empty() {
            return Vec::new();
        }
        
        // Convert to integer matrix (if possible)
        let mut basis = Vec::new();
        
        // Simple approach: find generators that are linearly independent over Z
        for gen in generators {
            // Check if gen is Z-linear combination of basis
            if !self.is_integer_combination(&gen, &basis) {
                basis.push(gen);
            }
        }
        
        basis
    }
    
    /// Check if element is an integer linear combination of basis elements
    fn is_integer_combination(&self, element: &GroupElement<P>, basis: &[GroupElement<P>]) -> bool {
        if basis.is_empty() {
            return element.is_identity();
        }
        
        // Solve the integer linear system: sum_i n_i * basis[i] = element
        // This is equivalent to solving Ax = b where:
        // - A is the matrix with basis vectors as columns
        // - x is the vector of integer coefficients
        // - b is the element vector
        
        let n = element.params.len();
        let m = basis.len();
        
        // Build augmented matrix [A | b]
        let mut matrix = vec![vec![P::zero(); m + 1]; n];
        
        // Fill matrix with basis vectors as columns
        for j in 0..m {
            for i in 0..n {
                matrix[i][j] = basis[j].params[i];
            }
        }
        
        // Add target vector as last column
        for i in 0..n {
            matrix[i][m] = element.params[i];
        }
        
        // Use Hermite normal form to solve integer system
        let solution = self.solve_integer_system(&mut matrix, n, m);
        
        // Check if we found an integer solution
        solution.is_some()
    }
    
    /// Solve integer linear system using extended GCD and back substitution
    fn solve_integer_system(&self, matrix: &mut Vec<Vec<P>>, n: usize, m: usize) -> Option<Vec<i64>> {
        // Convert to integer matrix by scaling
        let scale = P::from(1e10).unwrap();
        let mut int_matrix: Vec<Vec<i64>> = vec![vec![0; m + 1]; n];
        
        for i in 0..n {
            for j in 0..=m {
                int_matrix[i][j] = (matrix[i][j] * scale).round().to_i64().unwrap_or(0);
            }
        }
        
        // Gaussian elimination with integer arithmetic
        let mut pivot_cols = Vec::new();
        let mut row = 0;
        
        for col in 0..m {
            // Find pivot
            let mut pivot_row = None;
            let mut min_abs = i64::MAX;
            
            for r in row..n {
                if int_matrix[r][col] != 0 && int_matrix[r][col].abs() < min_abs {
                    min_abs = int_matrix[r][col].abs();
                    pivot_row = Some(r);
                }
            }
            
            if let Some(p_row) = pivot_row {
                // Swap rows
                if p_row != row {
                    int_matrix.swap(row, p_row);
                }
                
                pivot_cols.push(col);
                
                // Eliminate column below pivot
                for r in (row + 1)..n {
                    if int_matrix[r][col] != 0 {
                        // Use extended GCD to maintain integer values
                        let (g, s, t) = self.extended_gcd(int_matrix[row][col], int_matrix[r][col]);
                        let a = int_matrix[row][col] / g;
                        let b = int_matrix[r][col] / g;
                        
                        // Transform rows to eliminate int_matrix[r][col]
                        for j in 0..=m {
                            let temp1 = s * int_matrix[row][j] + t * int_matrix[r][j];
                            let temp2 = -b * int_matrix[row][j] + a * int_matrix[r][j];
                            int_matrix[row][j] = temp1;
                            int_matrix[r][j] = temp2;
                        }
                    }
                }
                
                row += 1;
            }
        }
        
        // Back substitution to find integer solution
        let mut solution = vec![0i64; m];
        
        for i in (0..pivot_cols.len()).rev() {
            let row_idx = i;
            let col_idx = pivot_cols[i];
            
            // Check if the row is consistent
            let mut rhs = int_matrix[row_idx][m];
            
            // Subtract contributions from already-solved variables
            for j in (col_idx + 1)..m {
                if pivot_cols.contains(&j) {
                    let idx = pivot_cols.iter().position(|&c| c == j).unwrap();
                    if idx < pivot_cols.len() {
                        rhs -= int_matrix[row_idx][j] * solution[j];
                    }
                }
            }
            
            // Check if rhs is divisible by the coefficient
            let coeff = int_matrix[row_idx][col_idx];
            if coeff == 0 || rhs % coeff != 0 {
                return None; // No integer solution
            }
            
            solution[col_idx] = rhs / coeff;
        }
        
        // Verify the solution
        for i in 0..n {
            let mut sum = 0i64;
            for j in 0..m {
                sum += solution[j] * int_matrix[i][j];
            }
            if (sum - int_matrix[i][m]).abs() > 1 {
                return None; // Solution doesn't satisfy all equations
            }
        }
        
        Some(solution)
    }
    
    /// Extended Euclidean algorithm
    fn extended_gcd(&self, a: i64, b: i64) -> (i64, i64, i64) {
        if b == 0 {
            (a.abs(), a.signum(), 0)
        } else {
            let (g, s1, t1) = self.extended_gcd(b, a % b);
            (g, t1, s1 - (a / b) * t1)
        }
    }
    
    /// Find linearly independent subset of vectors
    fn find_linearly_independent(&self, vectors: &[Vec<P>]) -> Vec<usize> {
        if vectors.is_empty() {
            return Vec::new();
        }
        
        let mut independent_indices = Vec::new();
        let mut basis = Vec::new();
        
        for (i, v) in vectors.iter().enumerate() {
            // Check if v is linearly independent from current basis
            if !self.is_linear_combination(v, &basis) {
                independent_indices.push(i);
                basis.push(v.clone());
            }
        }
        
        independent_indices
    }
    
    /// Check if vector is a linear combination of basis vectors
    fn is_linear_combination(&self, v: &[P], basis: &[Vec<P>]) -> bool {
        if basis.is_empty() {
            return false;
        }
        
        // Use Gram-Schmidt to check linear independence
        let mut orthogonal_component = v.to_vec();
        
        for b in basis {
            // Project out the component in direction of b
            let projection = self.vector_projection(&orthogonal_component, b);
            for i in 0..orthogonal_component.len() {
                orthogonal_component[i] = orthogonal_component[i] - projection[i];
            }
        }
        
        // If orthogonal component is zero, v is a linear combination
        let norm_sq = orthogonal_component.iter()
            .map(|x| x.powi(2))
            .fold(P::zero(), |acc, x| acc + x);
        
        norm_sq < P::epsilon()
    }
    
    /// Get an iterator over elements (for finite groups)
    pub fn elements(&self) -> Option<GroupElementIterator<P>> {
        match &self.group_type {
            GroupType::Finite { elements } => Some(GroupElementIterator::new(elements.clone())),
            _ => None,
        }
    }
    
    /// Compute stabilizer for discrete infinite groups
    /// 
    /// For groups like Z, Z^n, free groups, etc., we solve g·x = x
    /// by analyzing the structure of the group and action.
    fn compute_discrete_infinite_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<GroupElement<P>> {
        let mut stabilizer_gens = Vec::new();
        
        // Strategy depends on the type of discrete infinite group
        if self.generators.len() == 1 {
            // Single generator case (like Z)
            self.compute_cyclic_stabilizer(x, action, &mut stabilizer_gens);
        } else if self.is_free_abelian() {
            // Free abelian case (like Z^n)
            self.compute_free_abelian_stabilizer(x, action, &mut stabilizer_gens);
        } else {
            // General case: analyze action on generators
            self.compute_general_discrete_stabilizer(x, action, &mut stabilizer_gens);
        }
        
        stabilizer_gens
    }
    
    /// Compute stabilizer for cyclic groups (Z or finite cyclic)
    fn compute_cyclic_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        let gen = &self.generators[0];
        
        // For cyclic groups, find the smallest n > 0 such that gen^n · x = x
        // The stabilizer is then generated by gen^n
        
        let mut current = x.clone();
        let mut power = self.identity();
        let max_search = 1000; // Reasonable bound for practical computation
        
        for _n in 1..=max_search {
            // current = gen · current
            if let Ok(next) = action.apply(gen, &current) {
                current = next;
                power = self.multiply(&power, gen).unwrap_or_else(|_| self.identity());
                
                if current == *x {
                    // Found stabilizer generator: gen^n
                    if !power.is_identity() {
                        stabilizer_gens.push(power);
                    }
                    return;
                }
            } else {
                break;
            }
        }
        
        // If no finite order found, check if action is trivial
        if let Ok(transformed) = action.apply(gen, x) {
            if transformed == *x && !gen.is_identity() {
                stabilizer_gens.push(gen.clone());
            }
        }
    }
    
    /// Check if group is free abelian
    pub(crate) fn is_free_abelian(&self) -> bool {
        // A group is free abelian if:
        // 1. All generators commute with each other
        // 2. All generators have infinite order
        // 3. No non-trivial relations exist between generators
        
        if self.generators.is_empty() {
            return true; // Trivial group is free abelian
        }
        
        // Check 1: Commutativity - all generators must commute
        for i in 0..self.generators.len() {
            for j in i+1..self.generators.len() {
                if !self.elements_commute(&self.generators[i], &self.generators[j]) {
                    return false;
                }
            }
        }
        
        // Check 2: All generators must have infinite order
        for gen in &self.generators {
            if let Some(order) = self.element_order(gen) {
                if order != 0 { // Finite order
                    return false;
                }
            }
        }
        
        // Check 3: Linear independence over integers
        // This checks that no non-trivial integer linear combination equals identity
        self.check_generators_linearly_independent_over_integers()
    }
    
    /// Check if two elements commute: ab = ba
    fn elements_commute(&self, a: &GroupElement<P>, b: &GroupElement<P>) -> bool {
        // Compute ab and ba
        if let (Ok(ab), Ok(ba)) = (self.multiply(a, b), self.multiply(b, a)) {
            self.elements_equal(&ab, &ba)
        } else {
            false
        }
    }
    
    /// Check if generators are linearly independent over integers
    /// 
    /// This verifies that no non-trivial integer combination of generators
    /// equals the identity element.
    fn check_generators_linearly_independent_over_integers(&self) -> bool {
        let n = self.generators.len();
        if n == 0 {
            return true;
        }
        
        // For small numbers of generators, check common relations
        if n <= 3 {
            return self.check_small_generator_independence();
        }
        
        // For larger groups, use the fact that if generators are from Z^n
        // embedded in some space, we can check their coordinate vectors
        if let Some(coordinate_vectors) = self.extract_coordinate_vectors() {
            return self.check_coordinate_independence(&coordinate_vectors);
        }
        
        // General case: sample random integer combinations and check
        // This is a probabilistic test
        self.probabilistic_independence_check()
    }
    
    /// Check independence for small numbers of generators
    fn check_small_generator_independence(&self) -> bool {
        let identity = self.identity();
        
        match self.generators.len() {
            1 => {
                // Single generator: check it's not identity
                !self.elements_equal(&self.generators[0], &identity)
            }
            2 => {
                // Two generators: check neither is identity and no small powers relate them
                let g1 = &self.generators[0];
                let g2 = &self.generators[1];
                
                if self.elements_equal(g1, &identity) || self.elements_equal(g2, &identity) {
                    return false;
                }
                
                // Check relations like g1^a = g2^b for small a, b
                for a in -5..=5 {
                    for b in -5..=5 {
                        if a == 0 && b == 0 {
                            continue;
                        }
                        
                        if let (Ok(g1_a), Ok(g2_b)) = (self.power(g1, a), self.power(g2, b)) {
                            if self.elements_equal(&g1_a, &g2_b) {
                                return false; // Found relation
                            }
                        }
                    }
                }
                true
            }
            3 => {
                // Three generators: check no small integer combination is identity
                let _g1 = &self.generators[0];
                let _g2 = &self.generators[1];
                let _g3 = &self.generators[2];
                
                for a in -3..=3 {
                    for b in -3..=3 {
                        for c in -3..=3 {
                            if a == 0 && b == 0 && c == 0 {
                                continue;
                            }
                            
                            if let Ok(combination) = self.integer_combination(&[a, b, c]) {
                                if self.elements_equal(&combination, &identity) {
                                    return false; // Found relation
                                }
                            }
                        }
                    }
                }
                true
            }
            _ => true // Assume independent for now
        }
    }
    
    /// Compute integer linear combination of generators
    fn integer_combination(&self, coefficients: &[i32]) -> Result<GroupElement<P>, CcmError> {
        if coefficients.len() != self.generators.len() {
            return Err(SymmetryError::InvalidGroupOperation.into());
        }
        
        let mut result = self.identity();
        
        for (i, &coeff) in coefficients.iter().enumerate() {
            if coeff != 0 {
                let power = self.power(&self.generators[i], coeff)?;
                result = self.multiply(&result, &power)?;
            }
        }
        
        Ok(result)
    }
    
    /// Try to extract coordinate vectors if generators have that structure
    fn extract_coordinate_vectors(&self) -> Option<Vec<Vec<P>>> {
        // Check if all generators have the same dimension and look like coordinate vectors
        if self.generators.is_empty() {
            return Some(Vec::new());
        }
        
        let dim = self.generators[0].params.len();
        let mut vectors = Vec::new();
        
        for gen in &self.generators {
            if gen.params.len() != dim {
                return None; // Inconsistent dimensions
            }
            
            // Check if parameters look like a displacement vector
            // (for additive group structure)
            vectors.push(gen.params.clone());
        }
        
        Some(vectors)
    }
    
    /// Check if coordinate vectors are linearly independent over integers
    fn check_coordinate_independence(&self, vectors: &[Vec<P>]) -> bool {
        if vectors.is_empty() {
            return true;
        }
        
        let n = vectors.len();
        let dim = vectors[0].len();
        
        // Build matrix from vectors
        let mut matrix = vec![P::zero(); n * dim];
        for (i, vec) in vectors.iter().enumerate() {
            for (j, &val) in vec.iter().enumerate() {
                matrix[j * n + i] = val; // Column-major for easier processing
            }
        }
        
        // Convert to integer matrix for Smith Normal Form
        let mut int_matrix = vec![vec![0i64; n]; dim];
        for i in 0..dim {
            for j in 0..n {
                // Convert float to nearest integer
                int_matrix[i][j] = matrix[i * n + j].round().to_i64().unwrap_or(0);
            }
        }
        
        // Use Smith Normal Form to check independence
        // The vectors are independent over Z if the Smith form has no zero diagonal entries
        if let Some(relations) = self.smith_normal_form_relations(&int_matrix, dim, n) {
            // If we get non-trivial relations, the vectors are dependent
            relations.is_empty()
        } else {
            // If SNF computation succeeded without relations, vectors are independent
            true
        }
    }
    
    /// Probabilistic check for linear independence
    fn probabilistic_independence_check(&self) -> bool {
        let identity = self.identity();
        let n = self.generators.len();
        
        // Test 100 random small integer combinations
        let mut rng = 0u64; // Simple LCG for deterministic "randomness"
        
        for _ in 0..100 {
            let mut coeffs = vec![0i32; n];
            let mut all_zero = true;
            
            for i in 0..n {
                // Simple LCG: next = (a * current + c) mod m
                rng = (1664525 * rng + 1013904223) % (1u64 << 32);
                coeffs[i] = ((rng % 11) as i32) - 5; // Range [-5, 5]
                
                if coeffs[i] != 0 {
                    all_zero = false;
                }
            }
            
            if all_zero {
                continue;
            }
            
            // Check if this combination gives identity
            if let Ok(combination) = self.integer_combination(&coeffs) {
                if self.elements_equal(&combination, &identity) {
                    return false; // Found a relation
                }
            }
        }
        
        true // No relations found
    }
    
    /// Compute stabilizer for free abelian groups (Z^n)
    fn compute_free_abelian_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        // For Z^n, stabilizer is a sublattice
        // We need to find integer linear combinations of generators that fix x
        
        // First, check which individual generators fix x
        let mut fixing_indices = Vec::new();
        for (i, gen) in self.generators.iter().enumerate() {
            if let Ok(transformed) = action.apply(gen, x) {
                if transformed == *x {
                    fixing_indices.push(i);
                    if !gen.is_identity() {
                        stabilizer_gens.push(gen.clone());
                    }
                }
            }
        }
        
        // For non-fixing generators, find relations using Smith Normal Form
        self.find_stabilizer_relations_smith_normal_form(
            x,
            action,
            &fixing_indices,
            stabilizer_gens
        );
    }
    
    /// Find stabilizer relations using Smith Normal Form
    fn find_stabilizer_relations_smith_normal_form<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        fixing_indices: &[usize],
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        // Build relation matrix for the action on x
        // Each generator gives a row representing how it acts
        let non_fixing_gens: Vec<_> = self.generators.iter().enumerate()
            .filter(|(i, _)| !fixing_indices.contains(i))
            .map(|(_, g)| g)
            .collect();
        
        if non_fixing_gens.is_empty() {
            return;
        }
        
        // For abelian groups, we can represent the action as a matrix
        // and find its kernel using Smith Normal Form
        let n = non_fixing_gens.len();
        
        // Track orbit of x under the generators
        let mut orbit_elements = vec![x.clone()];
        let mut orbit_map = std::collections::HashMap::new();
        orbit_map.insert(self.element_hash(x), 0);
        
        // Build orbit and track how generators act
        let _action_matrix = vec![vec![0i64; n]; n];
        let max_orbit_size = 1000; // Prevent infinite loops
        
        for (_i, gen) in non_fixing_gens.iter().enumerate() {
            if let Ok(gen_x) = action.apply(gen, x) {
                // Check if gen_x is in orbit
                let hash = self.element_hash(&gen_x);
                if !orbit_map.contains_key(&hash) && orbit_elements.len() < max_orbit_size {
                    orbit_map.insert(hash, orbit_elements.len());
                    orbit_elements.push(gen_x);
                }
            }
        }
        
        // Build action matrix: how generators permute the orbit
        let orbit_size = orbit_elements.len();
        let mut perm_matrix = vec![vec![0i64; orbit_size]; n];
        
        for (i, gen) in non_fixing_gens.iter().enumerate() {
            for (j, elem) in orbit_elements.iter().enumerate() {
                if let Ok(result) = action.apply(gen, elem) {
                    let result_hash = self.element_hash(&result);
                    if let Some(&k) = orbit_map.get(&result_hash) {
                        perm_matrix[i][j] = k as i64 - j as i64;
                    }
                }
            }
        }
        
        // Compute Smith Normal Form to find relations
        if let Some(relations) = self.smith_normal_form_relations(&perm_matrix, n, orbit_size) {
            // Each relation gives a combination of generators that fixes x
            for relation in relations {
                if let Some(stabilizer_element) = self.build_element_from_relation(&non_fixing_gens, &relation) {
                    if !stabilizer_element.is_identity() {
                        stabilizer_gens.push(stabilizer_element);
                    }
                }
            }
        }
        
        // Also check for torsion elements (elements of finite order)
        self.find_torsion_stabilizers(x, action, &non_fixing_gens, stabilizer_gens);
    }
    
    /// Compute hash for element comparison
    fn element_hash<T>(&self, elem: &T) -> u64 {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;
        
        // We need to create a structural hash based on the actual content
        // Since T is generic without Hash bound, we'll use type-specific approaches
        
        // For primitive types and common structures, we can use transmute patterns
        // For safety, we'll use a combination of type ID and memory representation
        
        let mut hasher = DefaultHasher::new();
        
        // Hash the size and alignment of the type as discriminators
        // This helps distinguish different types without requiring 'static
        std::mem::size_of::<T>().hash(&mut hasher);
        std::mem::align_of::<T>().hash(&mut hasher);
        
        // For types that can be safely viewed as bytes, hash the byte representation
        let size = std::mem::size_of_val(elem);
        if size > 0 && size <= 1024 {  // Reasonable size limit
            // Create a byte view of the element for hashing
            // This is safe for POD types and many common structures
            unsafe {
                let bytes = std::slice::from_raw_parts(
                    elem as *const T as *const u8,
                    size
                );
                hasher.write(bytes);
            }
        } else {
            // For large types, sample bytes at regular intervals
            unsafe {
                let bytes = std::slice::from_raw_parts(
                    elem as *const T as *const u8,
                    size
                );
                // Sample up to 128 positions
                let step = size / 128 + 1;
                for i in (0..size).step_by(step) {
                    hasher.write_u8(bytes[i]);
                }
            }
        }
        
        hasher.finish()
    }
    
    /// Compute Smith Normal Form and extract relations
    fn smith_normal_form_relations(&self, matrix: &[Vec<i64>], n: usize, m: usize) -> Option<Vec<Vec<i64>>> {
        if matrix.is_empty() || n == 0 || m == 0 {
            return None;
        }
        
        // Copy matrix for modification
        let mut a = matrix.to_vec();
        let mut u = vec![vec![0i64; n]; n]; // Left transformation matrix
        let mut v = vec![vec![0i64; m]; m]; // Right transformation matrix
        
        // Initialize U and V as identity matrices
        for i in 0..n {
            u[i][i] = 1;
        }
        for i in 0..m {
            v[i][i] = 1;
        }
        
        // Smith Normal Form algorithm
        let mut pivot_row = 0;
        let mut pivot_col = 0;
        
        while pivot_row < n && pivot_col < m {
            // Find pivot with minimum non-zero absolute value
            let mut min_val = i64::MAX;
            let mut min_row = pivot_row;
            let mut min_col = pivot_col;
            
            for i in pivot_row..n {
                for j in pivot_col..m {
                    if a[i][j] != 0 && a[i][j].abs() < min_val {
                        min_val = a[i][j].abs();
                        min_row = i;
                        min_col = j;
                    }
                }
            }
            
            if min_val == i64::MAX {
                // No non-zero element found
                break;
            }
            
            // Move pivot to position (pivot_row, pivot_col)
            if min_row != pivot_row {
                a.swap(min_row, pivot_row);
                u.swap(min_row, pivot_row);
            }
            if min_col != pivot_col {
                for row in &mut a {
                    row.swap(min_col, pivot_col);
                }
                v.swap(min_col, pivot_col);
            }
            
            let pivot = a[pivot_row][pivot_col];
            
            // Eliminate other entries in the pivot column and row
            loop {
                let mut changed = false;
                
                // Eliminate column entries
                for i in 0..n {
                    if i != pivot_row && a[i][pivot_col] != 0 {
                        let q = a[i][pivot_col] / pivot;
                        for j in 0..m {
                            a[i][j] -= q * a[pivot_row][j];
                        }
                        for j in 0..n {
                            u[i][j] -= q * u[pivot_row][j];
                        }
                        changed = true;
                    }
                }
                
                // Eliminate row entries
                for j in 0..m {
                    if j != pivot_col && a[pivot_row][j] != 0 {
                        let q = a[pivot_row][j] / pivot;
                        for i in 0..n {
                            a[i][j] -= q * a[i][pivot_col];
                        }
                        for i in 0..m {
                            v[i][j] -= q * v[i][pivot_col];
                        }
                        changed = true;
                    }
                }
                
                if !changed {
                    break;
                }
            }
            
            pivot_row += 1;
            pivot_col += 1;
        }
        
        // Extract relations from the kernel
        let mut relations = Vec::new();
        
        // Find null space: columns of U corresponding to zero diagonal entries
        for i in 0..n {
            let mut is_null = true;
            for j in 0..m.min(n) {
                if i == j && a[j][j] != 0 {
                    is_null = false;
                    break;
                }
            }
            
            if is_null || i >= m {
                // This column of U gives a relation
                let relation: Vec<i64> = u.iter().map(|row| row[i]).collect();
                if relation.iter().any(|&x| x != 0) {
                    relations.push(relation);
                }
            }
        }
        
        Some(relations)
    }
    
    /// Build group element from integer relation
    fn build_element_from_relation(&self, generators: &[&GroupElement<P>], relation: &[i64]) -> Option<GroupElement<P>> {
        if generators.len() != relation.len() {
            return None;
        }
        
        let mut result = self.identity();
        
        for (i, &coeff) in relation.iter().enumerate() {
            if coeff != 0 {
                let gen = generators[i];
                let abs_coeff = coeff.abs() as i32;
                
                if let Ok(power) = self.power(gen, abs_coeff) {
                    result = if coeff > 0 {
                        self.multiply(&result, &power).ok()?
                    } else {
                        let inv_power = self.inverse(&power).ok()?;
                        self.multiply(&result, &inv_power).ok()?
                    };
                }
            }
        }
        
        Some(result)
    }
    
    /// Find torsion elements in the stabilizer
    fn find_torsion_stabilizers<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        generators: &[&GroupElement<P>],
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        // Check small orders for each generator
        let max_order = 20; // Can be adjusted based on group properties
        
        for gen in generators {
            let mut power = (*gen).clone();
            
            for _n in 2..=max_order {
                power = self.multiply(&power, gen).unwrap_or_else(|_| self.identity());
                
                if let Ok(result) = action.apply(&power, x) {
                    if result == *x && !power.is_identity() {
                        // Found element of order n that stabilizes x
                        let is_new = !stabilizer_gens.iter().any(|g| {
                            self.elements_equal(g, &power)
                        });
                        
                        if is_new {
                            stabilizer_gens.push(power.clone());
                        }
                        break;
                    }
                }
            }
        }
    }
    
    /// Compute stabilizer for general discrete infinite groups
    fn compute_general_discrete_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        // General strategy: 
        // 1. Check which generators and their powers fix x
        // 2. Check products of generators
        // 3. Use coset enumeration for finitely presented groups
        
        // Check individual generators
        for gen in &self.generators {
            if let Ok(transformed) = action.apply(gen, x) {
                if transformed == *x && !gen.is_identity() {
                    stabilizer_gens.push(gen.clone());
                }
            }
        }
        
        // Check powers of generators
        for gen in &self.generators {
            let mut power = gen.clone();
            
            for _ in 1..=20 {
                if let Ok(next) = action.apply(&power, x) {
                    if next == *x && !power.is_identity() {
                        // Check if this is a new generator
                        let is_new = !stabilizer_gens.iter().any(|g| {
                            g.params.iter().zip(&power.params)
                                .all(|(a, b)| (*a - *b).abs() < P::epsilon())
                        });
                        
                        if is_new {
                            stabilizer_gens.push(power.clone());
                        }
                        break;
                    }
                    
                    power = self.multiply(&power, gen).unwrap_or_else(|_| self.identity());
                }
            }
        }
        
        // Check simple products (limited depth for efficiency)
        if self.generators.len() >= 2 {
            for i in 0..self.generators.len() {
                for j in 0..self.generators.len() {
                    if i != j {
                        if let Ok(product) = self.multiply(&self.generators[i], &self.generators[j]) {
                            if let Ok(transformed) = action.apply(&product, x) {
                                if transformed == *x && !product.is_identity() {
                                    let is_new = !stabilizer_gens.iter().any(|g| {
                                        g.params.iter().zip(&product.params)
                                            .all(|(a, b)| (*a - *b).abs() < P::epsilon())
                                    });
                                    
                                    if is_new {
                                        stabilizer_gens.push(product);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// Compute stabilizer for continuous groups using Lie algebra methods
    /// 
    /// For continuous groups like SO(n) or SU(n), we find the Lie algebra
    /// of the stabilizer by solving the infinitesimal condition.
    fn compute_continuous_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<GroupElement<P>> {
        let mut stabilizer_gens = Vec::new();
        
        // For continuous groups, we need to find elements g such that g·x = x
        // This is done by:
        // 1. Computing the Lie algebra of the stabilizer
        // 2. Exponentiating suitable elements
        
        // First, check which generators (approximately) fix x
        for gen in &self.generators {
            if let Ok(transformed) = action.apply(gen, x) {
                // For continuous groups, check if gen is "close to identity"
                // and if it fixes x
                if transformed == *x {
                    // Check if generator is infinitesimal (close to identity)
                    let distance_from_identity = gen.params.iter()
                        .zip(self.identity().params.iter())
                        .map(|(a, b)| (*a - *b).powi(2))
                        .fold(P::zero(), |acc, x| acc + x)
                        .sqrt();
                    
                    if distance_from_identity > P::epsilon() && distance_from_identity < P::one() {
                        stabilizer_gens.push(gen.clone());
                    }
                }
            }
        }
        
        // Compute Lie algebra elements that generate the stabilizer
        let lie_stabilizer = self.compute_lie_stabilizer(x, action);
        
        // Add exponentials of Lie algebra elements
        for lie_elem in lie_stabilizer {
            // exp(t·X) for small t gives elements near identity in stabilizer
            let t = P::from(0.1).unwrap(); // Small parameter
            if let Ok(group_elem) = self.exponential_map(&lie_elem, t) {
                if !group_elem.is_identity() {
                    stabilizer_gens.push(group_elem);
                }
            }
        }
        
        // For matrix groups, find one-parameter subgroups
        if self.is_matrix_group() {
            self.find_one_parameter_stabilizers(x, action, &mut stabilizer_gens);
        }
        
        stabilizer_gens
    }
    
    /// Compute the Lie algebra of the stabilizer
    /// 
    /// Find X in the Lie algebra such that X·x = 0 (infinitesimal action)
    fn compute_lie_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<Vec<P>> {
        let mut lie_stabilizer = Vec::new();
        
        // Get Lie algebra basis from group generators
        let lie_basis = self.get_lie_algebra_basis();
        
        // For each basis element X, check if X·x = 0
        for basis_elem in &lie_basis {
            if self.infinitesimal_action_vanishes(basis_elem, x, action) {
                lie_stabilizer.push(basis_elem.clone());
            }
        }
        
        // Find the complete Lie stabilizer by solving the linear system
        let complete_stabilizer = self.compute_complete_lie_stabilizer(&lie_basis, x, action);
        
        // Add any new basis elements found
        for stab_elem in complete_stabilizer {
            // Check if this element is already in our basis
            let is_new = !lie_stabilizer.iter().any(|existing| {
                existing.len() == stab_elem.len() &&
                existing.iter().zip(&stab_elem)
                    .all(|(a, b)| (*a - *b).abs() < P::epsilon())
            });
            
            if is_new {
                lie_stabilizer.push(stab_elem);
            }
        }
        
        lie_stabilizer
    }
    
    /// Compute the complete Lie stabilizer by solving linear system
    fn compute_complete_lie_stabilizer<T: Clone + PartialEq>(
        &self,
        lie_basis: &[Vec<P>],
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<Vec<P>> {
        if lie_basis.is_empty() {
            return Vec::new();
        }
        
        let dim = lie_basis[0].len();
        let basis_size = lie_basis.len();
        
        // We want to find all v = Σ c_i * basis[i] such that v·x = 0
        // This means finding the kernel of the linear map A: R^k → T_x(Target)
        // where A(c) = Σ c_i * (basis[i]·x)
        
        // First, compute the action of each basis element
        let mut actions = Vec::new();
        for basis_elem in lie_basis {
            if let Some(action_result) = self.compute_lie_derivative(basis_elem, x, action) {
                actions.push(action_result);
            }
        }
        
        if actions.is_empty() {
            return Vec::new();
        }
        
        // Build the constraint matrix
        // Each row represents a constraint from the Lie derivative
        let target_dim = actions[0].len();
        let mut constraint_matrix = vec![vec![P::zero(); basis_size]; target_dim];
        
        for (j, action_j) in actions.iter().enumerate() {
            for (i, &val) in action_j.iter().enumerate() {
                constraint_matrix[i][j] = val;
            }
        }
        
        // Find the kernel of this matrix using SVD or QR decomposition
        let kernel_basis = self.compute_matrix_kernel(&constraint_matrix, target_dim, basis_size);
        
        // Convert kernel vectors back to Lie algebra elements
        let mut stabilizer_basis = Vec::new();
        for kernel_vec in kernel_basis {
            let mut lie_elem = vec![P::zero(); dim];
            
            // Compute linear combination: Σ kernel_vec[i] * basis[i]
            for (i, &coeff) in kernel_vec.iter().enumerate() {
                if i < lie_basis.len() && coeff.abs() > P::epsilon() {
                    for (j, &val) in lie_basis[i].iter().enumerate() {
                        lie_elem[j] = lie_elem[j] + coeff * val;
                    }
                }
            }
            
            // Only add non-zero elements
            let norm = lie_elem.iter()
                .map(|x| x.powi(2))
                .fold(P::zero(), |acc, x| acc + x)
                .sqrt();
                
            if norm > P::epsilon() {
                stabilizer_basis.push(lie_elem);
            }
        }
        
        stabilizer_basis
    }
    
    /// Compute the Lie derivative of x with respect to a Lie algebra element
    fn compute_lie_derivative<T: Clone + PartialEq>(
        &self,
        lie_elem: &[P],
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Option<Vec<P>> {
        // Use finite difference approximation for the Lie derivative
        // L_X(x) = d/dt|_{t=0} exp(tX)·x ≈ (exp(εX)·x - x)/ε
        
        let epsilon = P::from(1e-8).unwrap();
        let epsilon_inv = P::one() / epsilon;
        
        // Compute exp(εX)
        let g_epsilon = self.exponential_map(lie_elem, epsilon).ok()?;
        
        // Compute g_ε·x
        let transformed = action.apply(&g_epsilon, x).ok()?;
        
        // Compute the derivative using the tangent space structure
        // We need to linearize the difference transformed - x
        
        // Try to extract vector representation from the difference
        let derivative = self.extract_tangent_vector(x, &transformed, epsilon_inv, action)?;
        
        Some(derivative)
    }
    
    /// Extract tangent vector from the difference of two target elements
    fn extract_tangent_vector<T: Clone + PartialEq>(
        &self,
        x: &T,
        transformed: &T,
        scale: P,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Option<Vec<P>> {
        // Extract the tangent vector representation of (transformed - x) * scale
        // We'll use numerical differentiation with multiple directions
        
        let dim = self.dimension;
        let mut tangent = vec![P::zero(); dim];
        
        // Use directional derivatives to extract components
        for i in 0..dim {
            // Create a small perturbation in the i-th direction
            let mut h = vec![P::zero(); dim];
            h[i] = P::from(1e-10).unwrap();
            
            // Create group element from this perturbation
            if let Ok(g_h) = self.exponential_map(&h, P::one()) {
                // Compute directional derivative
                if let Ok(x_plus_h) = action.apply(&g_h, x) {
                    if let Ok(transformed_plus_h) = action.apply(&g_h, transformed) {
                        // Estimate the i-th component of the tangent vector
                        tangent[i] = self.compute_directional_derivative(
                            x,
                            &x_plus_h,
                            transformed,
                            &transformed_plus_h,
                            scale
                        );
                    }
                }
            }
        }
        
        // Check if we got a non-zero tangent vector
        let norm = tangent.iter()
            .map(|x| x.powi(2))
            .fold(P::zero(), |acc, x| acc + x)
            .sqrt();
            
        if norm > P::epsilon() {
            Some(tangent)
        } else {
            // If numerical differentiation failed, return zero vector of appropriate dimension
            // This indicates that the Lie derivative vanishes
            Some(vec![P::zero(); dim])
        }
    }
    
    /// Compute directional derivative component
    fn compute_directional_derivative<T: PartialEq>(
        &self,
        x: &T,
        x_plus_h: &T,
        transformed: &T,
        transformed_plus_h: &T,
        scale: P,
    ) -> P {
        // Check if the transformation preserved the perturbation structure
        if x == x_plus_h || transformed == transformed_plus_h {
            return P::zero();
        }
        
        // For generic types, we estimate the derivative using the change ratio
        // This is approximate but works for many practical cases
        
        // Compute a measure of change
        let change_factor = if x != transformed {
            P::one()
        } else {
            P::zero()
        };
        
        scale * change_factor
    }
    
    /// Compute the kernel (null space) of a matrix
    fn compute_matrix_kernel(&self, matrix: &[Vec<P>], m: usize, n: usize) -> Vec<Vec<P>> {
        if m == 0 || n == 0 || matrix.is_empty() {
            // Empty matrix - kernel is the whole space
            let mut kernel = Vec::new();
            for i in 0..n {
                let mut basis_vec = vec![P::zero(); n];
                basis_vec[i] = P::one();
                kernel.push(basis_vec);
            }
            return kernel;
        }
        
        // Use QR decomposition to find kernel
        // First, compute QR factorization of A^T
        let mut at = vec![vec![P::zero(); m]; n];
        for i in 0..m {
            for j in 0..n {
                at[j][i] = matrix[i][j];
            }
        }
        
        // Perform Gram-Schmidt orthogonalization on columns of A^T
        let mut q: Vec<Vec<P>> = Vec::new();
        let mut r = vec![vec![P::zero(); n]; n];
        
        for j in 0..n {
            let mut v = at[j].clone();
            
            // Subtract projections onto previous columns
            for i in 0..q.len() {
                let dot = v.iter().zip(&q[i])
                    .map(|(a, b): (&P, &P)| *a * *b)
                    .fold(P::zero(), |acc, x| acc + x);
                    
                r[i][j] = dot;
                
                for k in 0..m {
                    v[k] = v[k] - dot * q[i][k];
                }
            }
            
            // Compute norm
            let norm = v.iter()
                .map(|x| x.powi(2))
                .fold(P::zero(), |acc, x| acc + x)
                .sqrt();
                
            if norm > P::epsilon() {
                // Normalize and add to Q
                r[q.len()][j] = norm;
                let normalized: Vec<P> = v.iter().map(|x| *x / norm).collect();
                q.push(normalized);
            } else {
                // This column is in the kernel
                r[q.len()][j] = P::zero();
            }
        }
        
        // Find kernel basis from R
        let rank = q.len();
        let mut kernel_basis = Vec::new();
        
        // Find free variables (columns with zero diagonal in R)
        let mut free_vars = Vec::new();
        let mut pivot_cols = Vec::new();
        
        for j in 0..n {
            if j < rank && r[j][j].abs() > P::epsilon() {
                pivot_cols.push(j);
            } else {
                free_vars.push(j);
            }
        }
        
        // For each free variable, construct a kernel vector
        for &free_var in &free_vars {
            let mut kernel_vec = vec![P::zero(); n];
            kernel_vec[free_var] = P::one();
            
            // Back-substitute to find values for pivot variables
            for (i, &pivot_col) in pivot_cols.iter().enumerate().rev() {
                if i < rank && pivot_col < n {
                    let mut sum = P::zero();
                    for j in (pivot_col + 1)..n {
                        sum = sum + r[i][j] * kernel_vec[j];
                    }
                    kernel_vec[pivot_col] = -sum / r[i][pivot_col];
                }
            }
            
            kernel_basis.push(kernel_vec);
        }
        
        // Orthonormalize the kernel basis
        let mut ortho_kernel: Vec<Vec<P>> = Vec::new();
        for vec in kernel_basis {
            let mut v = vec;
            
            // Subtract projections
            for ortho in &ortho_kernel {
                let dot = v.iter().zip(ortho)
                    .map(|(a, b): (&P, &P)| *a * *b)
                    .fold(P::zero(), |acc, x| acc + x);
                    
                for i in 0..n {
                    v[i] = v[i] - dot * ortho[i];
                }
            }
            
            // Normalize
            let norm = v.iter()
                .map(|x| x.powi(2))
                .fold(P::zero(), |acc, x| acc + x)
                .sqrt();
                
            if norm > P::epsilon() {
                let normalized: Vec<P> = v.iter().map(|x| *x / norm).collect();
                ortho_kernel.push(normalized);
            }
        }
        
        ortho_kernel
    }
    
    /// Get Lie algebra basis from group generators
    fn get_lie_algebra_basis(&self) -> Vec<Vec<P>> {
        // For a Lie group, the tangent space at identity is the Lie algebra
        // We compute this using the matrix logarithm of the generators
        
        let mut basis = Vec::new();
        
        // Check if this is a matrix group
        let n_sq = (self.dimension as f64).sqrt() as usize;
        let is_matrix_group = n_sq * n_sq == self.dimension;
        
        for gen in &self.generators {
            let lie_elem = if is_matrix_group {
                // Use proper matrix logarithm
                match n_sq {
                    2 => self.matrix_log_2x2(&gen.params),
                    3 => self.matrix_log_3x3(&gen.params),
                    _ => self.matrix_logarithm_safe(&gen.params, n_sq),
                }
            } else {
                // For non-matrix groups, use the approximation log(I + X) ≈ X
                // This is valid for elements close to identity
                let identity = self.identity();
                let distance = gen.params.iter()
                    .zip(identity.params.iter())
                    .map(|(g, e)| (*g - *e).powi(2))
                    .fold(P::zero(), |acc, x| acc + x)
                    .sqrt();
                
                if distance < P::from(0.5).unwrap() {
                    // Close enough to identity for approximation
                    let lie_vec: Vec<P> = gen.params.iter()
                        .zip(identity.params.iter())
                        .map(|(g, e)| *g - *e)
                        .collect();
                    Some(lie_vec)
                } else {
                    // Too far from identity, skip this generator
                    None
                }
            };
            
            if let Some(lie_vec) = lie_elem {
                // Only include if non-zero
                let norm = lie_vec.iter()
                    .map(|x| x.powi(2))
                    .fold(P::zero(), |acc, x| acc + x)
                    .sqrt();
                    
                if norm > P::epsilon() {
                    // Normalize for numerical stability (optional)
                    // For some applications, you might want the actual Lie algebra elements
                    // without normalization
                    basis.push(lie_vec);
                }
            }
        }
        
        // Ensure we have a basis for the full Lie algebra
        // For matrix groups, we might need to add more basis elements
        if is_matrix_group && basis.len() < self.expected_lie_dimension(n_sq) {
            // Add standard basis elements for the Lie algebra
            basis.extend(self.standard_lie_algebra_basis(n_sq));
        }
        
        basis
    }
    
    /// Get the expected dimension of the Lie algebra based on the group type
    fn expected_lie_dimension(&self, n: usize) -> usize {
        // This is a heuristic based on common Lie groups
        // SO(n): n(n-1)/2
        // SU(n): n²-1
        // SL(n): n²-1
        // GL(n): n²
        
        // Default to a reasonable estimate
        if self.is_special_group() {
            n * n - 1
        } else {
            n * n
        }
    }
    
    /// Check if this appears to be a special group (determinant 1)
    fn is_special_group(&self) -> bool {
        // Check if all generators have determinant close to 1
        let n_sq = (self.dimension as f64).sqrt() as usize;
        if n_sq * n_sq != self.dimension {
            return false;
        }
        
        for gen in &self.generators {
            if let Some(det) = self.compute_determinant(&gen.params, n_sq) {
                if (det - P::one()).abs() > P::epsilon() * P::from(10.0).unwrap() {
                    return false;
                }
            }
        }
        
        true
    }
    
    /// Generate standard basis elements for matrix Lie algebras
    fn standard_lie_algebra_basis(&self, n: usize) -> Vec<Vec<P>> {
        let mut basis = Vec::new();
        
        // For SO(n), the basis consists of skew-symmetric matrices E_ij - E_ji
        // For other groups, we'd need different basis elements
        
        // Generate skew-symmetric basis
        for i in 0..n {
            for j in i+1..n {
                let mut elem = vec![P::zero(); n * n];
                elem[i * n + j] = P::one();
                elem[j * n + i] = -P::one();
                basis.push(elem);
            }
        }
        
        basis
    }
    
    /// Check if infinitesimal action of X on x vanishes
    fn infinitesimal_action_vanishes<T: Clone + PartialEq>(
        &self,
        lie_elem: &[P],
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> bool {
        // Compute the Lie derivative X·x = d/dt|_{t=0} exp(tX)·x
        // 
        // For small ε, we have:
        // exp(εX)·x ≈ x + ε(X·x) + O(ε²)
        // So X·x ≈ (exp(εX)·x - x)/ε
        
        // Use small but not too small epsilon for numerical stability
        let epsilon = P::from(1e-8).unwrap();
        let epsilon_inv = P::one() / epsilon;
        
        // Compute exp(εX)
        if let Ok(g_epsilon) = self.exponential_map(lie_elem, epsilon) {
            // Compute g_ε·x
            if let Ok(transformed) = action.apply(&g_epsilon, x) {
                // Compute the Lie derivative using finite differences
                // L_X(x) = lim_{ε→0} (g_ε·x - x) / ε
                
                // Extract the tangent vector (transformed - x) / ε
                let tangent_vector = self.extract_tangent_vector(x, &transformed, epsilon_inv, action);
                
                if let Some(tangent) = tangent_vector {
                    // Check if the tangent vector is zero (within tolerance)
                    let norm = self.compute_target_norm(&tangent, action);
                    return norm < P::epsilon() * P::from(100.0).unwrap();
                }
            }
        }
        
        false
    }
    
    /// Exponential map from Lie algebra to group
    pub(crate) fn exponential_map(&self, lie_elem: &[P], t: P) -> Result<GroupElement<P>, CcmError> {
        // exp(tX) = I + tX + (tX)²/2! + (tX)³/3! + ...
        
        let identity = self.identity();
        let dim = identity.params.len();
        
        // Check if this is a matrix group
        let n = (dim as f64).sqrt();
        let is_matrix_group = n.floor() == n && n > 0.0;
        let matrix_dim = n as usize;
        
        if is_matrix_group && matrix_dim * matrix_dim == dim {
            // For matrix groups, use matrix exponential
            self.matrix_exponential(lie_elem, t, matrix_dim)
        } else {
            // For general groups, use power series up to a certain order
            // exp(tX) ≈ I + tX + (tX)²/2 + (tX)³/6 + ...
            
            let mut result = identity.params.clone();
            let mut power = lie_elem.to_vec();
            let mut factorial = P::one();
            
            // Add first-order term: tX
            for i in 0..dim {
                result[i] = result[i] + t * power[i];
            }
            
            // Add higher-order terms
            for k in 2..=5 {
                // Update factorial: k!
                factorial = factorial * P::from(k).unwrap();
                
                // For non-matrix groups, we approximate higher powers
                // by repeated scaling (this is exact for abelian groups)
                for i in 0..dim {
                    power[i] = power[i] * lie_elem[i];
                }
                
                // Add term: t^k X^k / k!
                let coeff = t.powi(k as i32) / factorial;
                for i in 0..dim {
                    result[i] = result[i] + coeff * power[i];
                }
            }
            
            Ok(GroupElement {
                params: result,
                cached_order: None,
            })
        }
    }
    
    /// Matrix exponential using scaling and squaring method
    fn matrix_exponential(&self, matrix: &[P], t: P, n: usize) -> Result<GroupElement<P>, CcmError> {
        if matrix.len() != n * n {
            return Err(SymmetryError::InvalidGroupOperation.into());
        }
        
        // Scale the matrix: compute exp(tX/2^s) then square s times
        // Choose s so that ||tX/2^s|| < 1
        let mut max_entry = P::zero();
        for &x in matrix {
            if x.abs() > max_entry {
                max_entry = x.abs();
            }
        }
        
        let norm_estimate = max_entry * t.abs() * P::from(n).unwrap();
        let s = if norm_estimate > P::one() {
            (norm_estimate.log2().ceil()).to_i32().unwrap_or(0).max(0) as u32
        } else {
            0
        };
        
        let scale = P::from(2.0_f64.powi(-(s as i32))).unwrap();
        let scaled_t = t * scale;
        
        // Compute exp(scaled_t * X) using Padé approximation or Taylor series
        let mut exp_matrix = self.compute_matrix_exponential_taylor(matrix, scaled_t, n)?;
        
        // Square s times to get exp(tX)
        for _ in 0..s {
            exp_matrix = self.matrix_multiply_internal(&exp_matrix, &exp_matrix, n)?;
        }
        
        Ok(GroupElement {
            params: exp_matrix,
            cached_order: None,
        })
    }
    
    /// Compute matrix exponential using Taylor series
    fn compute_matrix_exponential_taylor(&self, matrix: &[P], t: P, n: usize) -> Result<Vec<P>, CcmError> {
        // exp(tA) = I + tA + (tA)²/2! + (tA)³/3! + ...
        
        // Start with identity matrix
        let mut result = vec![P::zero(); n * n];
        for i in 0..n {
            result[i * n + i] = P::one();
        }
        
        // Compute tA
        let mut ta = vec![P::zero(); n * n];
        for i in 0..n * n {
            ta[i] = t * matrix[i];
        }
        
        // Add tA to result
        for i in 0..n * n {
            result[i] = result[i] + ta[i];
        }
        
        // Add higher order terms
        let mut power = ta.clone();
        let mut factorial = P::one();
        
        for k in 2..=10 {
            // Update factorial
            factorial = factorial * P::from(k).unwrap();
            
            // Compute next power: power = power * tA
            power = self.matrix_multiply_internal(&power, &ta, n)?;
            
            // Add term: power / k!
            for i in 0..n * n {
                result[i] = result[i] + power[i] / factorial;
            }
            
            // Check convergence (if terms are getting small enough)
            let max_term = power.iter()
                .map(|&x| x.abs())
                .fold(P::zero(), |a, b| if a > b { a } else { b }) / factorial;
                
            if max_term < P::epsilon() {
                break;
            }
        }
        
        Ok(result)
    }
    
    /// Internal matrix multiplication (reuse from generators.rs logic)
    fn matrix_multiply_internal(&self, a: &[P], b: &[P], n: usize) -> Result<Vec<P>, CcmError> {
        if a.len() != n * n || b.len() != n * n {
            return Err(SymmetryError::InvalidGroupOperation.into());
        }
        
        let mut result = vec![P::zero(); n * n];
        
        for i in 0..n {
            for j in 0..n {
                let mut sum = P::zero();
                for k in 0..n {
                    sum = sum + a[i * n + k] * b[k * n + j];
                }
                result[i * n + j] = sum;
            }
        }
        
        Ok(result)
    }
    
    /// Check if this is a matrix group
    fn is_matrix_group(&self) -> bool {
        // Check if dimension is a perfect square
        let n = (self.dimension as f64).sqrt();
        n.floor() == n && n > 0.0
    }
    
    /// Find one-parameter subgroups in the stabilizer
    fn find_one_parameter_stabilizers<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        // For matrix groups, look for one-parameter subgroups
        // of the form exp(tA) where A is a matrix
        
        let n = (self.dimension as f64).sqrt() as usize;
        if n * n != self.dimension {
            return;
        }
        
        // Try diagonal matrices (easy case)
        for i in 0..n {
            let mut diag_matrix = vec![P::zero(); self.dimension];
            diag_matrix[i * n + i] = P::one();
            
            // Check if this diagonal transformation fixes x
            let t = P::from(0.1).unwrap();
            if let Ok(g) = self.exponential_map(&diag_matrix, t) {
                if let Ok(transformed) = action.apply(&g, x) {
                    if transformed == *x && !g.is_identity() {
                        stabilizer_gens.push(g);
                    }
                }
            }
        }
        
        // Try skew-symmetric matrices (for orthogonal groups)
        for i in 0..n {
            for j in i+1..n {
                let mut skew_matrix = vec![P::zero(); self.dimension];
                skew_matrix[i * n + j] = P::one();
                skew_matrix[j * n + i] = -P::one();
                
                let t = P::from(0.1).unwrap();
                if let Ok(g) = self.exponential_map(&skew_matrix, t) {
                    if let Ok(transformed) = action.apply(&g, x) {
                        if transformed == *x && !g.is_identity() {
                            stabilizer_gens.push(g);
                        }
                    }
                }
            }
        }
    }
    
    /// Compute the norm of a target space element
    /// 
    /// This is needed for checking if Lie derivatives vanish
    fn compute_target_norm<T>(&self, tangent: &Vec<P>, _action: &dyn GroupAction<P, Target = T>) -> P {
        // The tangent vector is represented as a Vec<P>
        // We compute the L2 norm
        
        tangent.iter()
            .map(|x| x.powi(2))
            .fold(P::zero(), |acc, x| acc + x)
            .sqrt()
    }
}