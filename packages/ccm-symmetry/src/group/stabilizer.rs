//! Stabilizer subgroup computation
//! 
//! The stabilizer of x under G is:
//! Stab_G(x) = {g ∈ G : g·x = x}
//! 
//! This module provides stabilizer computation for all group types.

use num_traits::Float;
use crate::group::{GroupElement, SymmetryGroup, StabilizerSubgroup, GroupType};
use crate::actions::GroupAction;
use crate::iterator::GroupElementIterator;
use ccm_core::CcmError;

/// Trait for computing stabilizer subgroups
pub trait StabilizerComputation<P: Float> {
    /// Compute the stabilizer of an element
    fn compute_stabilizer<T: Clone + PartialEq>(
        &self,
        element: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> StabilizerSubgroup<P>;
    
    /// Compute generators of the stabilizer
    fn compute_stabilizer_generators<T: Clone + PartialEq>(
        &self,
        element: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<GroupElement<P>>;
    
    /// Minimize stabilizer generators
    fn minimize_stabilizer_generators(
        &self,
        generators: Vec<GroupElement<P>>,
    ) -> StabilizerSubgroup<P>;
}

impl<P: Float> SymmetryGroup<P> {
    /// Compute the stabilizer subgroup of an element
    /// 
    /// The stabilizer is the subgroup of elements that fix the given element
    pub fn stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> StabilizerSubgroup<P> {
        let mut stabilizer_generators = Vec::new();
        
        match &self.group_type {
            GroupType::Finite { elements } => {
                // For finite groups, check which elements fix x
                for g in elements {
                    if let Ok(transformed) = action.apply(g, x) {
                        if transformed == *x && !g.is_identity() {
                            stabilizer_generators.push(g.clone());
                        }
                    }
                }
            }
            GroupType::DiscreteInfinite => {
                // For discrete infinite groups, solve g·x = x systematically
                stabilizer_generators = self.compute_discrete_infinite_stabilizer(x, action);
            }
            GroupType::Continuous => {
                // For continuous groups, use Lie algebra methods
                stabilizer_generators = self.compute_continuous_stabilizer(x, action);
            }
        }
        
        // Minimize the generator set
        self.minimize_stabilizer_generators(stabilizer_generators)
    }
    
    /// Minimize a set of stabilizer generators
    /// 
    /// This removes redundant generators to find a minimal generating set
    fn minimize_stabilizer_generators(
        &self,
        generators: Vec<GroupElement<P>>,
    ) -> StabilizerSubgroup<P> {
        if generators.is_empty() {
            return StabilizerSubgroup {
                generators: Vec::new(),
            };
        }
        
        // First, remove duplicates
        let mut unique_gens = Vec::new();
        for gen in generators {
            let is_duplicate = unique_gens.iter().any(|g: &GroupElement<P>| {
                self.elements_equal(g, &gen)
            });
            
            if !is_duplicate && !gen.is_identity() {
                unique_gens.push(gen);
            }
        }
        
        // Now minimize the generating set
        let minimal = match &self.group_type {
            GroupType::Finite { .. } => {
                self.minimize_finite_generators(unique_gens)
            }
            GroupType::DiscreteInfinite => {
                self.minimize_discrete_generators(unique_gens)
            }
            GroupType::Continuous => {
                self.minimize_continuous_generators(unique_gens)
            }
        };
        
        StabilizerSubgroup {
            generators: minimal,
        }
    }
    
    /// Check if two group elements are equal
    pub(crate) fn elements_equal(&self, a: &GroupElement<P>, b: &GroupElement<P>) -> bool {
        a.params.len() == b.params.len() &&
        a.params.iter().zip(&b.params)
            .all(|(x, y)| (*x - *y).abs() < P::epsilon())
    }
    
    /// Minimize generators for finite groups
    fn minimize_finite_generators(&self, generators: Vec<GroupElement<P>>) -> Vec<GroupElement<P>> {
        let mut minimal = Vec::new();
        let mut generated_so_far = vec![self.identity()];
        
        // Greedy algorithm: add generators that increase the generated subgroup
        for gen in generators {
            // Check if gen is already in the subgroup generated by minimal
            if !self.is_in_subgroup(&gen, &generated_so_far) {
                minimal.push(gen.clone());
                
                // Update generated_so_far with new elements
                let mut new_elements = Vec::new();
                for g in &generated_so_far {
                    if let Ok(product) = self.multiply(g, &gen) {
                        if !self.is_in_subgroup(&product, &generated_so_far) {
                            new_elements.push(product);
                        }
                    }
                    if let Ok(inv_gen) = self.inverse(&gen) {
                        if let Ok(product) = self.multiply(g, &inv_gen) {
                            if !self.is_in_subgroup(&product, &generated_so_far) {
                                new_elements.push(product);
                            }
                        }
                    }
                }
                generated_so_far.extend(new_elements);
            }
        }
        
        minimal
    }
    
    /// Minimize generators for discrete infinite groups
    fn minimize_discrete_generators(&self, generators: Vec<GroupElement<P>>) -> Vec<GroupElement<P>> {
        // For discrete infinite groups, use different strategies based on type
        
        // Check if we have a free abelian group (Z^n)
        if self.is_free_abelian() && generators.len() > 1 {
            return self.minimize_free_abelian_generators(generators);
        }
        
        // For general discrete groups, use redundancy elimination
        let mut minimal = Vec::new();
        
        for (i, gen) in generators.iter().enumerate() {
            // Check if gen can be expressed using other generators
            let others: Vec<_> = generators.iter().enumerate()
                .filter(|(j, _)| *j != i)
                .map(|(_, g)| g.clone())
                .collect();
            
            if others.is_empty() || !self.can_express_with_generators(gen, &others) {
                minimal.push(gen.clone());
            }
        }
        
        minimal
    }
    
    /// Minimize generators for continuous groups
    fn minimize_continuous_generators(&self, generators: Vec<GroupElement<P>>) -> Vec<GroupElement<P>> {
        // For continuous groups, minimize the Lie algebra generators
        
        // Convert to Lie algebra elements
        let lie_elements: Vec<Vec<P>> = generators.iter()
            .map(|gen| {
                gen.params.iter()
                    .zip(self.identity().params.iter())
                    .map(|(g, e)| *g - *e)
                    .collect()
            })
            .collect();
        
        // Find linearly independent subset
        let independent_indices = self.find_linearly_independent(&lie_elements);
        
        // Return corresponding group elements
        independent_indices.into_iter()
            .map(|i| generators[i].clone())
            .collect()
    }
    
    /// Check if element is in the subgroup
    fn is_in_subgroup(&self, element: &GroupElement<P>, subgroup: &[GroupElement<P>]) -> bool {
        subgroup.iter().any(|g| self.elements_equal(g, element))
    }
    
    /// Minimize generators for free abelian groups (Z^n)
    fn minimize_free_abelian_generators(&self, generators: Vec<GroupElement<P>>) -> Vec<GroupElement<P>> {
        // For Z^n, we want to find a basis
        // Use Hermite normal form or similar
        
        if generators.is_empty() {
            return Vec::new();
        }
        
        // Convert to integer matrix (if possible)
        let mut basis = Vec::new();
        
        // Simple approach: find generators that are linearly independent over Z
        for gen in generators {
            // Check if gen is Z-linear combination of basis
            if !self.is_integer_combination(&gen, &basis) {
                basis.push(gen);
            }
        }
        
        basis
    }
    
    /// Check if element is an integer linear combination of basis elements
    fn is_integer_combination(&self, element: &GroupElement<P>, basis: &[GroupElement<P>]) -> bool {
        if basis.is_empty() {
            return false;
        }
        
        // This is a simplified check
        // Full implementation would solve integer linear system
        
        // For now, check if element is a multiple of any basis element
        for b in basis {
            if let Some(ratio) = self.find_integer_ratio(&element.params, &b.params) {
                let rounded = ratio.round();
                if (ratio - rounded).abs() < P::epsilon() {
                    return true;
                }
            }
        }
        
        false
    }
    
    /// Find linearly independent subset of vectors
    fn find_linearly_independent(&self, vectors: &[Vec<P>]) -> Vec<usize> {
        if vectors.is_empty() {
            return Vec::new();
        }
        
        let mut independent_indices = Vec::new();
        let mut basis = Vec::new();
        
        for (i, v) in vectors.iter().enumerate() {
            // Check if v is linearly independent from current basis
            if !self.is_linear_combination(v, &basis) {
                independent_indices.push(i);
                basis.push(v.clone());
            }
        }
        
        independent_indices
    }
    
    /// Check if vector is a linear combination of basis vectors
    fn is_linear_combination(&self, v: &[P], basis: &[Vec<P>]) -> bool {
        if basis.is_empty() {
            return false;
        }
        
        // Use Gram-Schmidt to check linear independence
        let mut orthogonal_component = v.to_vec();
        
        for b in basis {
            // Project out the component in direction of b
            let projection = self.vector_projection(&orthogonal_component, b);
            for i in 0..orthogonal_component.len() {
                orthogonal_component[i] = orthogonal_component[i] - projection[i];
            }
        }
        
        // If orthogonal component is zero, v is a linear combination
        let norm_sq = orthogonal_component.iter()
            .map(|x| x.powi(2))
            .fold(P::zero(), |acc, x| acc + x);
        
        norm_sq < P::epsilon()
    }
    
    /// Get an iterator over elements (for finite groups)
    pub fn elements(&self) -> Option<GroupElementIterator<P>> {
        match &self.group_type {
            GroupType::Finite { elements } => Some(GroupElementIterator::new(elements.clone())),
            _ => None,
        }
    }
    
    /// Compute stabilizer for discrete infinite groups
    /// 
    /// For groups like Z, Z^n, free groups, etc., we solve g·x = x
    /// by analyzing the structure of the group and action.
    fn compute_discrete_infinite_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<GroupElement<P>> {
        let mut stabilizer_gens = Vec::new();
        
        // Strategy depends on the type of discrete infinite group
        if self.generators.len() == 1 {
            // Single generator case (like Z)
            self.compute_cyclic_stabilizer(x, action, &mut stabilizer_gens);
        } else if self.is_free_abelian() {
            // Free abelian case (like Z^n)
            self.compute_free_abelian_stabilizer(x, action, &mut stabilizer_gens);
        } else {
            // General case: analyze action on generators
            self.compute_general_discrete_stabilizer(x, action, &mut stabilizer_gens);
        }
        
        stabilizer_gens
    }
    
    /// Compute stabilizer for cyclic groups (Z or finite cyclic)
    fn compute_cyclic_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        let gen = &self.generators[0];
        
        // For cyclic groups, find the smallest n > 0 such that gen^n · x = x
        // The stabilizer is then generated by gen^n
        
        let mut current = x.clone();
        let mut power = self.identity();
        let max_search = 1000; // Reasonable bound for practical computation
        
        for n in 1..=max_search {
            // current = gen · current
            if let Ok(next) = action.apply(gen, &current) {
                current = next;
                power = self.multiply(&power, gen).unwrap_or_else(|_| self.identity());
                
                if current == *x {
                    // Found stabilizer generator: gen^n
                    if !power.is_identity() {
                        stabilizer_gens.push(power);
                    }
                    return;
                }
            } else {
                break;
            }
        }
        
        // If no finite order found, check if action is trivial
        if let Ok(transformed) = action.apply(gen, x) {
            if transformed == *x && !gen.is_identity() {
                stabilizer_gens.push(gen.clone());
            }
        }
    }
    
    /// Check if group is free abelian
    pub(crate) fn is_free_abelian(&self) -> bool {
        // Heuristic: multiple generators with commutative structure
        // Full check would verify relations
        self.generators.len() > 1 && self.generators.len() <= 10
    }
    
    /// Compute stabilizer for free abelian groups (Z^n)
    fn compute_free_abelian_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        // For Z^n, stabilizer is a sublattice
        // We need to find integer linear combinations of generators that fix x
        
        // First, check which individual generators fix x
        let mut fixing_indices = Vec::new();
        for (i, gen) in self.generators.iter().enumerate() {
            if let Ok(transformed) = action.apply(gen, x) {
                if transformed == *x {
                    fixing_indices.push(i);
                    if !gen.is_identity() {
                        stabilizer_gens.push(gen.clone());
                    }
                }
            }
        }
        
        // For non-fixing generators, find relations
        // This is simplified - full implementation would use Smith normal form
        for i in 0..self.generators.len() {
            if fixing_indices.contains(&i) {
                continue;
            }
            
            // Check if some power fixes x
            let gen = &self.generators[i];
            let mut current = x.clone();
            let mut power = self.identity();
            
            for n in 1..=100 {
                if let Ok(next) = action.apply(gen, &current) {
                    current = next;
                    power = self.multiply(&power, gen).unwrap_or_else(|_| self.identity());
                    
                    if current == *x {
                        if !power.is_identity() {
                            stabilizer_gens.push(power);
                        }
                        break;
                    }
                }
            }
        }
    }
    
    /// Compute stabilizer for general discrete infinite groups
    fn compute_general_discrete_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        // General strategy: 
        // 1. Check which generators and their powers fix x
        // 2. Check products of generators
        // 3. Use coset enumeration for finitely presented groups
        
        // Check individual generators
        for gen in &self.generators {
            if let Ok(transformed) = action.apply(gen, x) {
                if transformed == *x && !gen.is_identity() {
                    stabilizer_gens.push(gen.clone());
                }
            }
        }
        
        // Check powers of generators
        for gen in &self.generators {
            let mut current = x.clone();
            let mut power = gen.clone();
            
            for _ in 1..=20 {
                if let Ok(next) = action.apply(&power, x) {
                    if next == *x && !power.is_identity() {
                        // Check if this is a new generator
                        let is_new = !stabilizer_gens.iter().any(|g| {
                            g.params.iter().zip(&power.params)
                                .all(|(a, b)| (*a - *b).abs() < P::epsilon())
                        });
                        
                        if is_new {
                            stabilizer_gens.push(power.clone());
                        }
                        break;
                    }
                    
                    current = next;
                    power = self.multiply(&power, gen).unwrap_or_else(|_| self.identity());
                }
            }
        }
        
        // Check simple products (limited depth for efficiency)
        if self.generators.len() >= 2 {
            for i in 0..self.generators.len() {
                for j in 0..self.generators.len() {
                    if i != j {
                        if let Ok(product) = self.multiply(&self.generators[i], &self.generators[j]) {
                            if let Ok(transformed) = action.apply(&product, x) {
                                if transformed == *x && !product.is_identity() {
                                    let is_new = !stabilizer_gens.iter().any(|g| {
                                        g.params.iter().zip(&product.params)
                                            .all(|(a, b)| (*a - *b).abs() < P::epsilon())
                                    });
                                    
                                    if is_new {
                                        stabilizer_gens.push(product);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// Compute stabilizer for continuous groups using Lie algebra methods
    /// 
    /// For continuous groups like SO(n) or SU(n), we find the Lie algebra
    /// of the stabilizer by solving the infinitesimal condition.
    fn compute_continuous_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<GroupElement<P>> {
        let mut stabilizer_gens = Vec::new();
        
        // For continuous groups, we need to find elements g such that g·x = x
        // This is done by:
        // 1. Computing the Lie algebra of the stabilizer
        // 2. Exponentiating suitable elements
        
        // First, check which generators (approximately) fix x
        for gen in &self.generators {
            if let Ok(transformed) = action.apply(gen, x) {
                // For continuous groups, check if gen is "close to identity"
                // and if it fixes x
                if transformed == *x {
                    // Check if generator is infinitesimal (close to identity)
                    let distance_from_identity = gen.params.iter()
                        .zip(self.identity().params.iter())
                        .map(|(a, b)| (*a - *b).powi(2))
                        .fold(P::zero(), |acc, x| acc + x)
                        .sqrt();
                    
                    if distance_from_identity > P::epsilon() && distance_from_identity < P::one() {
                        stabilizer_gens.push(gen.clone());
                    }
                }
            }
        }
        
        // Compute Lie algebra elements that generate the stabilizer
        let lie_stabilizer = self.compute_lie_stabilizer(x, action);
        
        // Add exponentials of Lie algebra elements
        for lie_elem in lie_stabilizer {
            // exp(t·X) for small t gives elements near identity in stabilizer
            let t = P::from(0.1).unwrap(); // Small parameter
            if let Ok(group_elem) = self.exponential_map(&lie_elem, t) {
                if !group_elem.is_identity() {
                    stabilizer_gens.push(group_elem);
                }
            }
        }
        
        // For matrix groups, find one-parameter subgroups
        if self.is_matrix_group() {
            self.find_one_parameter_stabilizers(x, action, &mut stabilizer_gens);
        }
        
        stabilizer_gens
    }
    
    /// Compute the Lie algebra of the stabilizer
    /// 
    /// Find X in the Lie algebra such that X·x = 0 (infinitesimal action)
    fn compute_lie_stabilizer<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> Vec<Vec<P>> {
        let mut lie_stabilizer = Vec::new();
        
        // Get Lie algebra basis from group generators
        let lie_basis = self.get_lie_algebra_basis();
        
        // For each basis element X, check if X·x = 0
        for basis_elem in lie_basis {
            if self.infinitesimal_action_vanishes(&basis_elem, x, action) {
                lie_stabilizer.push(basis_elem);
            }
        }
        
        // Find linear combinations that also work
        // This is simplified - full implementation would solve linear system
        if lie_stabilizer.len() >= 2 {
            // Check simple linear combinations
            for i in 0..lie_stabilizer.len().min(3) {
                for j in i+1..lie_stabilizer.len().min(4) {
                    let combination: Vec<P> = lie_stabilizer[i].iter()
                        .zip(&lie_stabilizer[j])
                        .map(|(a, b)| *a + *b)
                        .collect();
                    
                    if self.infinitesimal_action_vanishes(&combination, x, action) {
                        lie_stabilizer.push(combination);
                    }
                }
            }
        }
        
        lie_stabilizer
    }
    
    /// Get Lie algebra basis from group generators
    fn get_lie_algebra_basis(&self) -> Vec<Vec<P>> {
        // For a Lie group, the tangent space at identity is the Lie algebra
        // We approximate this using the generators
        
        let mut basis = Vec::new();
        
        for gen in &self.generators {
            // Compute log(gen) to get Lie algebra element
            // For now, approximate as (gen - I) for elements near identity
            let lie_elem: Vec<P> = gen.params.iter()
                .zip(self.identity().params.iter())
                .map(|(g, e)| *g - *e)
                .collect();
            
            // Only include if non-zero
            let norm = lie_elem.iter()
                .map(|x| x.powi(2))
                .fold(P::zero(), |acc, x| acc + x)
                .sqrt();
                
            if norm > P::epsilon() {
                // Normalize for numerical stability
                let normalized: Vec<P> = lie_elem.iter()
                    .map(|x| *x / norm)
                    .collect();
                basis.push(normalized);
            }
        }
        
        basis
    }
    
    /// Check if infinitesimal action of X on x vanishes
    fn infinitesimal_action_vanishes<T: Clone + PartialEq>(
        &self,
        lie_elem: &[P],
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
    ) -> bool {
        // Compute X·x = d/dt|_{t=0} exp(tX)·x
        // Approximate using finite differences
        
        let epsilon = P::from(1e-6).unwrap();
        
        // Compute exp(εX)
        if let Ok(g_epsilon) = self.exponential_map(lie_elem, epsilon) {
            // Compute g_ε·x
            if let Ok(transformed) = action.apply(&g_epsilon, x) {
                // Check if (g_ε·x - x)/ε ≈ 0
                // This is simplified - full implementation would compute proper derivative
                return transformed == *x;
            }
        }
        
        false
    }
    
    /// Exponential map from Lie algebra to group
    pub(crate) fn exponential_map(&self, lie_elem: &[P], t: P) -> Result<GroupElement<P>, CcmError> {
        // exp(tX) = I + tX + (tX)²/2! + ...
        // For now, use first-order approximation
        
        let identity = self.identity();
        let params: Vec<P> = identity.params.iter()
            .zip(lie_elem.iter())
            .map(|(e, x)| *e + t * *x)
            .collect();
        
        Ok(GroupElement {
            params,
            cached_order: None,
        })
    }
    
    /// Check if this is a matrix group
    fn is_matrix_group(&self) -> bool {
        // Check if dimension is a perfect square
        let n = (self.dimension as f64).sqrt();
        n.floor() == n && n > 0.0
    }
    
    /// Find one-parameter subgroups in the stabilizer
    fn find_one_parameter_stabilizers<T: Clone + PartialEq>(
        &self,
        x: &T,
        action: &dyn GroupAction<P, Target = T>,
        stabilizer_gens: &mut Vec<GroupElement<P>>,
    ) {
        // For matrix groups, look for one-parameter subgroups
        // of the form exp(tA) where A is a matrix
        
        let n = (self.dimension as f64).sqrt() as usize;
        if n * n != self.dimension {
            return;
        }
        
        // Try diagonal matrices (easy case)
        for i in 0..n {
            let mut diag_matrix = vec![P::zero(); self.dimension];
            diag_matrix[i * n + i] = P::one();
            
            // Check if this diagonal transformation fixes x
            let t = P::from(0.1).unwrap();
            if let Ok(g) = self.exponential_map(&diag_matrix, t) {
                if let Ok(transformed) = action.apply(&g, x) {
                    if transformed == *x && !g.is_identity() {
                        stabilizer_gens.push(g);
                    }
                }
            }
        }
        
        // Try skew-symmetric matrices (for orthogonal groups)
        for i in 0..n {
            for j in i+1..n {
                let mut skew_matrix = vec![P::zero(); self.dimension];
                skew_matrix[i * n + j] = P::one();
                skew_matrix[j * n + i] = -P::one();
                
                let t = P::from(0.1).unwrap();
                if let Ok(g) = self.exponential_map(&skew_matrix, t) {
                    if let Ok(transformed) = action.apply(&g, x) {
                        if transformed == *x && !g.is_identity() {
                            stabilizer_gens.push(g);
                        }
                    }
                }
            }
        }
    }
}