//! Infinite discrete group implementations
//! 
//! This module handles infinite discrete groups such as:
//! - Integers under addition (Z)
//! - Integer lattices (Z^n)
//! - Free groups
//! - Finitely presented groups

use num_traits::Float;
use crate::group::{GroupElement, SymmetryGroup, GroupType};
use crate::SymmetryError;
use ccm_core::CcmError;

/// Trait for infinite discrete group operations
pub trait InfiniteGroup<P: Float> {
    /// Check if element is in the group (word problem)
    fn contains(&self, element: &GroupElement<P>) -> bool;
    
    /// Find a word representation in terms of generators
    fn word_representation(&self, element: &GroupElement<P>) -> Option<Vec<(usize, i32)>>;
    
    /// Solve equations in the group
    fn solve_equation(&self, lhs: &GroupElement<P>, rhs: &GroupElement<P>) -> Option<GroupElement<P>>;
}

impl<P: Float> InfiniteGroup<P> for SymmetryGroup<P> {
    /// Check if element is in the group (word problem)
    fn contains(&self, element: &GroupElement<P>) -> bool {
        self.contains(element)
    }
    
    /// Find a word representation in terms of generators
    fn word_representation(&self, element: &GroupElement<P>) -> Option<Vec<(usize, i32)>> {
        self.express_as_word(element)
    }
    
    /// Solve equations in the group
    fn solve_equation(&self, lhs: &GroupElement<P>, rhs: &GroupElement<P>) -> Option<GroupElement<P>> {
        // Solve lhs * x = rhs for x
        // This means x = lhs^(-1) * rhs
        
        match self.inverse(lhs) {
            Ok(lhs_inv) => {
                match self.multiply(&lhs_inv, rhs) {
                    Ok(solution) => Some(solution),
                    Err(_) => None,
                }
            }
            Err(_) => None,
        }
    }
}

impl<P: Float> SymmetryGroup<P> {
    /// Generate the infinite cyclic group Z
    /// 
    /// The infinite cyclic group is generated by a single element
    /// with no relations (except the group axioms).
    pub fn integers(dimension: usize) -> Result<Self, CcmError> {
        if dimension == 0 {
            return Err(SymmetryError::InvalidGroupOperation.into());
        }
        
        let mut group = Self::generate(dimension)?;
        
        // Single generator that represents +1
        let generator = GroupElement {
            params: vec![P::one(); dimension],
            cached_order: None, // Infinite order
        };
        
        group.generators = vec![generator];
        group.group_type = GroupType::DiscreteInfinite;
        group.cached_order = None; // Infinite
        
        Ok(group)
    }
    
    /// Generate the integer lattice Z^n
    /// 
    /// The integer lattice in n dimensions is the direct product
    /// of n copies of Z.
    pub fn integer_lattice(n: usize) -> Result<Self, CcmError> {
        if n == 0 {
            return Err(SymmetryError::InvalidGroupOperation.into());
        }
        
        let mut group = Self::generate(n)?;
        let mut generators = Vec::new();
        
        // Create n generators, each representing a unit vector
        for i in 0..n {
            let mut params = vec![P::zero(); n];
            params[i] = P::one();
            generators.push(GroupElement {
                params,
                cached_order: None, // Infinite order
            });
        }
        
        group.generators = generators;
        group.group_type = GroupType::DiscreteInfinite;
        group.cached_order = None; // Infinite
        
        Ok(group)
    }
}